###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.1.8447/W32 for ARM        13/Feb/2017  13:48:09
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-LIB\lib_mem.c
#    Command line =  
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Source\Micrium\uC-LIB\lib_mem.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_HD -D DEBUG -D STM32F103RB -D
#        STM32_FLASH_SIZE=128 -lCN "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\" -o "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\" --debug --endian=little
#        --cpu=ARM7TDMI -e --fpu=None --dlib_config "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01 智能电表\Library\Project\IAR\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\AES\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\User\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Port\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\OS\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\SIM900A\Config\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\APP\Protocol\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Driver\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\IAR\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\uCOS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\CoreSupport\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\St\FWLib\STM32F10x_StdPeriph_Driver\inc\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-LIB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\BSP\Os\OSAL\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\OSAL\OS\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Cfg\Template\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\OS\uCOS-III\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-MB\Source\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\" -I
#        "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\Micrium\uC-OS-III\Source\"
#        -I "V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\" -I "V:\我的项目\04
#        长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\..\..\Source\FatFs\option\" --cpu_mode
#        thumb -Oh --use_c++_inline
#    List file    =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\List\lib_mem.lst
#    Object file  =  
#        V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04
#        程序\NC014-001-000.CX_01
#        智能电表\Library\Project\IAR\Debug-RB\Obj\lib_mem.o
#
###############################################################################

V:\我的项目\04 长沙南车\2015年后项目\NC16-011-A 智能电表\04 程序\NC014-001-000.CX_01 智能电表\Library\Source\Micrium\uC-LIB\lib_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/LIB
      4          *                                        CUSTOM LIBRARY MODULES
      5          *
      6          *                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/LIB is provided in source form to registered licensees ONLY.  It is
     11          *               illegal to distribute this source code to any third party unless you receive
     12          *               written permission by an authorized Micrium representative.  Knowledge of
     13          *               the source code may NOT be used to develop a similar product.
     14          *
     15          *               Please help us continue to provide the Embedded community with the finest
     16          *               software available.  Your honesty is greatly appreciated.
     17          *
     18          *               You can contact us at www.micrium.com.
     19          *********************************************************************************************************
     20          */
     21          
     22          /*
     23          *********************************************************************************************************
     24          *
     25          *                                     STANDARD MEMORY OPERATIONS
     26          *
     27          * Filename      : lib_mem.c
     28          * Version       : V1.37.01
     29          * Programmer(s) : ITJ
     30          *                 FGK
     31          *                 JFD
     32          *                 FBJ
     33          *********************************************************************************************************
     34          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     35          *
     36          *                     (a) ALL standard library functions are implemented in the custom library modules :
     37          *
     38          *                         (1) \<Custom Library Directory>\lib_*.*
     39          *
     40          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     41          *
     42          *                               where
     43          *                                       <Custom Library Directory>      directory path for custom library software
     44          *                                       <cpu>                           directory name for specific processor (CPU)
     45          *                                       <compiler>                      directory name for specific compiler
     46          *
     47          *                     (b) Product-specific library functions are implemented in individual products.
     48          *********************************************************************************************************
     49          */
     50          
     51          
     52          /*
     53          *********************************************************************************************************
     54          *                                            INCLUDE FILES
     55          *********************************************************************************************************
     56          */
     57          
     58          #define    MICRIUM_SOURCE
     59          #define    LIB_MEM_MODULE
     60          #include  <lib_mem.h>
     61          
     62          
     63          /*$PAGE*/
     64          /*
     65          *********************************************************************************************************
     66          *                                            LOCAL DEFINES
     67          *********************************************************************************************************
     68          */
     69          
     70          
     71          /*
     72          *********************************************************************************************************
     73          *                                           LOCAL CONSTANTS
     74          *********************************************************************************************************
     75          */
     76          
     77          
     78          /*
     79          *********************************************************************************************************
     80          *                                          LOCAL DATA TYPES
     81          *********************************************************************************************************
     82          */
     83          
     84          
     85          /*
     86          *********************************************************************************************************
     87          *                                            LOCAL TABLES
     88          *********************************************************************************************************
     89          */
     90          
     91          
     92          /*
     93          *********************************************************************************************************
     94          *                                       LOCAL GLOBAL VARIABLES
     95          *********************************************************************************************************
     96          */
     97          
     98          #if     (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
     99          MEM_POOL    *Mem_PoolTbl;                                               /* Mem      pool/seg tbl.                       */
    100          MEM_POOL     Mem_PoolHeap;                                              /* Mem heap pool/seg.                           */
    101          
    102          #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR
    103          CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                           /* Mem heap.                                    */
    104          #endif
    105          #endif
    106          
    107          
    108          /*
    109          *********************************************************************************************************
    110          *                                      LOCAL FUNCTION PROTOTYPES
    111          *********************************************************************************************************
    112          */
    113          
    114          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)                               /* -------------- MEM POOL FNCTS -------------- */
    115          
    116          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    117          static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr(MEM_POOL          *pmem_pool,
    118                                                       void              *pmem_blk);
    119          #endif
    120          
    121          
    122          static  CPU_SIZE_T    Mem_SegCalcTotSize    (void              *pmem_addr,
    123                                                       MEM_POOL_BLK_QTY   blk_nbr,
    124                                                       CPU_SIZE_T         blk_size,
    125                                                       CPU_SIZE_T         blk_align);
    126          
    127          static  void         *Mem_SegAlloc          (MEM_POOL          *pmem_pool,
    128                                                       CPU_SIZE_T         size,
    129                                                       CPU_SIZE_T         align);
    130          
    131          #endif
    132          
    133          
    134          /*
    135          *********************************************************************************************************
    136          *                                     LOCAL CONFIGURATION ERRORS
    137          *********************************************************************************************************
    138          */
    139          
    140          
    141          /*$PAGE*/
    142          /*
    143          *********************************************************************************************************
    144          *                                             Mem_Init()
    145          *
    146          * Description : (1) Initialize Memory Management Module :
    147          *
    148          *                   (a) Initialize heap memory pool
    149          *                   (b) Initialize      memory pool table
    150          *
    151          *
    152          * Argument(s) : none.
    153          *
    154          * Return(s)   : none.
    155          *
    156          * Caller(s)   : Application.
    157          *
    158          * Note(s)     : (2) Mem_Init() MUST be called ... :
    159          *
    160          *                   (a) ONLY ONCE from a product's application; ...
    161          *                   (b) BEFORE product's application calls any memory library module function(s)
    162          *********************************************************************************************************
    163          */
    164          

   \                                 In section .text, align 2, keep-with-next
    165          void  Mem_Init (void)
    166          {
    167          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    168              MEM_POOL  *pmem_pool;
    169          
    170                                                                                  /* --------- INIT MEM HEAP SEG / POOL --------- */
    171              pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
    172              pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
    173              pmem_pool->SegHeadPtr       = (MEM_POOL   *)&Mem_PoolHeap;          /* Heap seg head = heap seg.                    */
    174              pmem_pool->SegPrevPtr       = (MEM_POOL   *) 0;
    175              pmem_pool->SegNextPtr       = (MEM_POOL   *) 0;
    176              pmem_pool->PoolPrevPtr      = (MEM_POOL   *) 0;
    177              pmem_pool->PoolNextPtr      = (MEM_POOL   *) 0;
    178              pmem_pool->PoolAddrStart    = (void       *) 0;
    179              pmem_pool->PoolAddrEnd      = (void       *) 0;
    180              pmem_pool->PoolPtrs         = (void      **) 0;
    181              pmem_pool->BlkSize          = (CPU_SIZE_T  ) 0u;
    182              pmem_pool->BlkNbr           = (CPU_SIZE_T  ) 0u;
    183              pmem_pool->BlkIx            = (MEM_POOL_IX ) 0u;
    184          
    185          #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
    186              pmem_pool->SegAddr          = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    187              pmem_pool->SegAddrNextAvail = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    188          #else
    189              pmem_pool->SegAddr          = (void       *)&Mem_Heap[0];
    190              pmem_pool->SegAddrNextAvail = (void       *)&Mem_Heap[0];
    191          #endif
    192          
    193              pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
    194              pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
    195          
    196                                                                                  /* ------------ INIT MEM POOL TBL ------------- */
    197              Mem_PoolTbl = &Mem_PoolHeap;
    198          #endif
    199          }
   \                     Mem_Init: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    200          
    201          
    202          /*$PAGE*/
    203          /*
    204          *********************************************************************************************************
    205          *                                              Mem_Clr()
    206          *
    207          * Description : Clear data buffer (see Note #2).
    208          *
    209          * Argument(s) : pmem        Pointer to memory buffer to clear.
    210          *
    211          *               size        Number of data buffer octets to clear (see Note #1).
    212          *
    213          * Return(s)   : none.
    214          *
    215          * Caller(s)   : Application.
    216          *
    217          * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
    218          *
    219          *                   See also 'Mem_Set()  Note #1'.
    220          *
    221          *               (2) Clear data by setting each data octet to 0.
    222          *********************************************************************************************************
    223          */
    224          

   \                                 In section .text, align 2, keep-with-next
    225          void  Mem_Clr (void        *pmem,
    226                         CPU_SIZE_T   size)
    227          {
    228              Mem_Set(pmem,
    229                      0u,                                                 /* See Note #2.                                         */
    230                      size);
   \                     Mem_Clr: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD100             BNE      ??Mem_Clr_0
   \   00000004   0x4770             BX       LR
   \                     ??Mem_Clr_0: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD017             BEQ      ??Mem_Clr_1
   \   0000000C   0x0782             LSLS     R2,R0,#+30
   \   0000000E   0x0F92             LSRS     R2,R2,#+30
   \   00000010   0xD008             BEQ      ??Mem_Clr_2
   \                     ??Mem_Clr_3: (+1)
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x7003             STRB     R3,[R0, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x1E49             SUBS     R1,R1,#+1
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD00D             BEQ      ??Mem_Clr_1
   \   00000020   0x2A04             CMP      R2,#+4
   \   00000022   0xD3F6             BCC      ??Mem_Clr_3
   \                     ??Mem_Clr_2: (+1)
   \   00000024   0x2904             CMP      R1,#+4
   \   00000026   0xD305             BCC      ??Mem_Clr_4
   \                     ??Mem_Clr_5: (+1)
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x6002             STR      R2,[R0, #+0]
   \   0000002C   0x1D00             ADDS     R0,R0,#+4
   \   0000002E   0x1F09             SUBS     R1,R1,#+4
   \   00000030   0x2904             CMP      R1,#+4
   \   00000032   0xD2F9             BCS      ??Mem_Clr_5
   \                     ??Mem_Clr_4: (+1)
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD001             BEQ      ??Mem_Clr_1
   \   00000038   0x.... 0x....      BL       __aeabi_memclr
    231          }
   \                     ??Mem_Clr_1: (+1)
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return
    232          
    233          
    234          /*$PAGE*/
    235          /*
    236          *********************************************************************************************************
    237          *                                              Mem_Set()
    238          *
    239          * Description : Fill data buffer with specified data octet.
    240          *
    241          * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
    242          *
    243          *               data_val    Data fill octet value.
    244          *
    245          *               size        Number of data buffer octets to fill (see Note #1).
    246          *
    247          * Return(s)   : none.
    248          *
    249          * Caller(s)   : Application.
    250          *
    251          * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
    252          *
    253          *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
    254          *                   words.
    255          *
    256          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    257          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    258          *                       addresses.
    259          *
    260          *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    261          *                   address boundary.
    262          *
    263          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    264          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    265          *                  'mem_align_mod' arithmetic operation.
    266          *********************************************************************************************************
    267          */
    268          

   \                                 In section .text, align 2, keep-with-next
    269          void  Mem_Set (void        *pmem,
    270                         CPU_INT08U   data_val,
    271                         CPU_SIZE_T   size)
    272          {
   \                     Mem_Set: (+1)
   \   00000000   0x000B             MOVS     R3,R1
   \   00000002   0x0011             MOVS     R1,R2
    273              CPU_SIZE_T   size_rem;
    274              CPU_ALIGN    data_align;
    275              CPU_ALIGN   *pmem_align;
    276              CPU_INT08U  *pmem_08;
    277              CPU_DATA     mem_align_mod;
    278              CPU_DATA     i;
    279          
    280          
    281          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    282              if (size < 1) {                                             /* See Note #1.                                         */
   \   00000004   0xD100             BNE      ??Mem_Set_0
   \   00000006   0x4770             BX       LR
    283                  return;
    284              }
    285              if (pmem == (void *)0) {
   \                     ??Mem_Set_0: (+1)
   \   00000008   0xB510             PUSH     {R4,LR}
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD01D             BEQ      ??Mem_Set_1
    286                  return;
    287              }
    288          #endif
    289          
    290          
    291              data_align = 0u;
    292              for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
   \   0000000E   0x001A             MOVS     R2,R3
    293                  data_align <<=  DEF_OCTET_NBR_BITS;
    294                  data_align  |= (CPU_ALIGN)data_val;
   \   00000010   0x0214             LSLS     R4,R2,#+8
   \   00000012   0x4314             ORRS     R4,R4,R2
   \   00000014   0x0224             LSLS     R4,R4,#+8
   \   00000016   0x4314             ORRS     R4,R4,R2
   \   00000018   0x0224             LSLS     R4,R4,#+8
   \   0000001A   0x4322             ORRS     R2,R2,R4
    295              }
    296          
    297              size_rem      =  size;
    298              mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
   \   0000001C   0x0784             LSLS     R4,R0,#+30
   \   0000001E   0x0FA4             LSRS     R4,R4,#+30
    299          
    300              pmem_08 = (CPU_INT08U *)pmem;
    301              if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
   \   00000020   0xD007             BEQ      ??Mem_Set_2
    302                  i = mem_align_mod;
    303                  while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
    304                         (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
    305                     *pmem_08++ = data_val;
   \                     ??Mem_Set_3: (+1)
   \   00000022   0x7003             STRB     R3,[R0, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
    306                      size_rem -= sizeof(CPU_INT08U);
   \   00000026   0x1E49             SUBS     R1,R1,#+1
    307                      i++;
   \   00000028   0x1C64             ADDS     R4,R4,#+1
    308                  }
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD00D             BEQ      ??Mem_Set_1
   \   0000002E   0x2C04             CMP      R4,#+4
   \   00000030   0xD3F7             BCC      ??Mem_Set_3
    309              }
    310          
    311              pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
   \                     ??Mem_Set_2: (+1)
   \   00000032   0x2904             CMP      R1,#+4
   \   00000034   0xD304             BCC      ??Mem_Set_4
    312              while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
    313                 *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
   \                     ??Mem_Set_5: (+1)
   \   00000036   0x6002             STR      R2,[R0, #+0]
   \   00000038   0x1D00             ADDS     R0,R0,#+4
    314                  size_rem    -= sizeof(CPU_ALIGN);
   \   0000003A   0x1F09             SUBS     R1,R1,#+4
    315              }
   \   0000003C   0x2904             CMP      R1,#+4
   \   0000003E   0xD2FA             BCS      ??Mem_Set_5
    316          
    317              pmem_08 = (CPU_INT08U *)pmem_align;
    318              while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
   \                     ??Mem_Set_4: (+1)
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD002             BEQ      ??Mem_Set_1
    319                 *pmem_08++   = data_val;
   \   00000044   0x001A             MOVS     R2,R3
   \   00000046   0x.... 0x....      BL       __aeabi_memset
    320                  size_rem   -= sizeof(CPU_INT08U);
    321              }
    322          }
   \                     ??Mem_Set_1: (+1)
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    323          
    324          
    325          /*$PAGE*/
    326          /*
    327          *********************************************************************************************************
    328          *                                             Mem_Copy()
    329          *
    330          * Description : Copy data octets from one memory buffer to another memory buffer.
    331          *
    332          * Argument(s) : pdest       Pointer to destination memory buffer.
    333          *
    334          *               psrc        Pointer to source      memory buffer.
    335          *
    336          *               size        Number of octets to copy (see Note #1).
    337          *
    338          * Return(s)   : none.
    339          *
    340          * Caller(s)   : Application.
    341          *
    342          * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
    343          *
    344          *               (2) Memory buffers NOT checked for overlapping.
    345          *
    346          *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
    347          *                       copying takes place between objects that overlap, the behavior is undefined".
    348          *
    349          *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
    350          *                       successfully copy to a destination memory buffer at a lower  address value even
    351          *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
    352          *                       word copy overlaps.
    353          *
    354          *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
    355          *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
    356          *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
    357          *                       ever overlap.
    358          *
    359          *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
    360          *                       buffers as long as the source memory buffer is at a higher address value than the
    361          *                       destination memory buffer.
    362          *
    363          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    364          *                   words.
    365          *
    366          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    367          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    368          *                       addresses.
    369          *
    370          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    371          *                   address boundary.
    372          *
    373          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    374          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    375          *                  'mem_align_mod' arithmetic operation.
    376          *********************************************************************************************************
    377          */
    378          /*$PAGE*/
    379          #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
    380          void  Mem_Copy (       void        *pdest,
    381                          const  void        *psrc,
    382                                 CPU_SIZE_T   size)
    383          {
    384                     CPU_SIZE_T    size_rem;
    385                     CPU_SIZE_T    mem_gap_octets;
    386                     CPU_ALIGN    *pmem_align_dest;
    387              const  CPU_ALIGN    *pmem_align_src;
    388                     CPU_INT08U   *pmem_08_dest;
    389              const  CPU_INT08U   *pmem_08_src;
    390                     CPU_DATA      i;
    391                     CPU_DATA      mem_align_mod_dest;
    392                     CPU_DATA      mem_align_mod_src;
    393                     CPU_BOOLEAN   mem_aligned;
    394          
    395          
    396          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    397              if (size < 1) {                                             /* See Note #1.                                         */
    398                  return;
    399              }
    400              if (pdest == (void *)0) {
    401                  return;
    402              }
    403              if (psrc  == (void *)0) {
    404                  return;
    405              }
    406          #endif
    407          
    408          
    409              size_rem           =  size;
    410          
    411              pmem_08_dest       = (      CPU_INT08U *)pdest;
    412              pmem_08_src        = (const CPU_INT08U *)psrc;
    413          
    414              mem_gap_octets     = pmem_08_src - pmem_08_dest;
    415          
    416          
    417              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
    418                                                                          /* See Note #4.                                         */
    419                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
    420                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
    421          
    422                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
    423          
    424                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
    425                                                                          /* ... optimize copy for mem buf alignment.             */
    426                      if (mem_align_mod_dest != 0u) {                     /* If leading octets avail,                   ...       */
    427                          i = mem_align_mod_dest;
    428                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    429                                 (i          <  sizeof(CPU_ALIGN ))) {    /* ... until next CPU_ALIGN word boundary.              */
    430                             *pmem_08_dest++ = *pmem_08_src++;
    431                              size_rem      -=  sizeof(CPU_INT08U);
    432                              i++;
    433                          }
    434                      }
    435          
    436                      pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;  /* See Note #3a.                                        */
    437                      pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
    438                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    439                         *pmem_align_dest++ = *pmem_align_src++;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
    440                          size_rem         -=  sizeof(CPU_ALIGN);
    441                      }
    442          
    443                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
    444                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
    445                  }
    446              }
    447          
    448              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    449                 *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
    450                  size_rem      -=  sizeof(CPU_INT08U);
    451              }
    452          }
    453          #endif
    454          
    455          
    456          /*
    457          *********************************************************************************************************
    458          *                                             Mem_Move()
    459          *
    460          * Description : Move data octets from one memory buffer to another memory buffer, or within the same
    461          *               memory buffer. Overlapping is correctly handled for all move operations.
    462          *
    463          * Argument(s) : pdest       Pointer to destination memory buffer.
    464          *
    465          *               psrc        Pointer to source      memory buffer.
    466          *
    467          *               size        Number of octets to move (see Note #1).
    468          *
    469          * Return(s)   : none.
    470          *
    471          * Caller(s)   : Application.
    472          *
    473          * Note(s)     : (1) Null move operations allowed (i.e. zero-length).
    474          *
    475          *               (2) Memory buffers checked for overlapping.
    476          *
    477          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    478          *                   words.
    479          *
    480          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    481          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    482          *                       addresses.
    483          *
    484          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    485          *                   address boundary.
    486          *
    487          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    488          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    489          *                  'mem_align_mod' arithmetic operation.
    490          *********************************************************************************************************
    491          */
    492          /*$PAGE*/
    493          

   \                                 In section .text, align 2, keep-with-next
    494          void  Mem_Move (       void        *pdest,
    495                          const  void        *psrc,
    496                                 CPU_SIZE_T   size)
    497          {
    498                     CPU_SIZE_T    size_rem;
    499                     CPU_SIZE_T    mem_gap_octets;
    500                     CPU_ALIGN    *pmem_align_dest;
    501              const  CPU_ALIGN    *pmem_align_src;
    502                     CPU_INT08U   *pmem_08_dest;
    503              const  CPU_INT08U   *pmem_08_src;
    504                     CPU_INT08S    i;
    505                     CPU_DATA      mem_align_mod_dest;
    506                     CPU_DATA      mem_align_mod_src;
    507                     CPU_BOOLEAN   mem_aligned;
    508          
    509          
    510          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    511              if (size < 1) {
   \                     Mem_Move: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0xD100             BNE      ??Mem_Move_0
   \   00000004   0x4770             BX       LR
    512                  return;
    513              }
    514              if (pdest == (void *)0) {
   \                     ??Mem_Move_0: (+1)
   \   00000006   0xB510             PUSH     {R4,LR}
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD035             BEQ      ??Mem_Move_1
    515                  return;
    516              }
    517              if (psrc  == (void *)0) {
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD033             BEQ      ??Mem_Move_1
    518                  return;
    519              }
    520          #endif
    521          
    522              pmem_08_src  = (const CPU_INT08U *)psrc;
    523              pmem_08_dest = (      CPU_INT08U *)pdest;
    524              if (pmem_08_src > pmem_08_dest) {
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD202             BCS      ??Mem_Move_2
    525                  Mem_Copy(pdest, psrc, size);
   \   00000014   0x.... 0x....      BL       Mem_Copy
    526                  return;
   \   00000018   0xBD10             POP      {R4,PC}
    527              }
    528          
    529              size_rem           =  size;
    530          
    531              pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
   \                     ??Mem_Move_2: (+1)
   \   0000001A   0x1880             ADDS     R0,R0,R2
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
    532              pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
   \   0000001E   0x1889             ADDS     R1,R1,R2
   \   00000020   0x1E49             SUBS     R1,R1,#+1
    533              
    534              mem_gap_octets     = pmem_08_dest - pmem_08_src;
    535              
    536          
    537              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
   \   00000022   0x1A43             SUBS     R3,R0,R1
   \   00000024   0x2B04             CMP      R3,#+4
   \   00000026   0xD321             BCC      ??Mem_Move_3
    538              
    539                                                                          /* See Note #4.                                         */
    540                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
   \   00000028   0x2303             MOVS     R3,#+3
   \   0000002A   0x2403             MOVS     R4,#+3
   \   0000002C   0x4004             ANDS     R4,R4,R0
    541                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
    542          
    543                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
   \   0000002E   0x400B             ANDS     R3,R3,R1
   \   00000030   0x429C             CMP      R4,R3
   \   00000032   0xD11B             BNE      ??Mem_Move_3
    544          
    545                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
    546                                                                          /* ... optimize copy for mem buf alignment.             */
    547                      if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
   \   00000034   0x2C03             CMP      R4,#+3
   \   00000036   0xD00A             BEQ      ??Mem_Move_4
    548                          i = mem_align_mod_dest;
   \                     ??Mem_Move_5: (+1)
   \   00000038   0x0624             LSLS     R4,R4,#+24
   \   0000003A   0x1624             ASRS     R4,R4,#+24
   \   0000003C   0xD407             BMI      ??Mem_Move_4
    549                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    550                                 (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
    551                             *pmem_08_dest-- = *pmem_08_src--;
   \   0000003E   0x780B             LDRB     R3,[R1, #+0]
   \   00000040   0x7003             STRB     R3,[R0, #+0]
   \   00000042   0x1E49             SUBS     R1,R1,#+1
   \   00000044   0x1E40             SUBS     R0,R0,#+1
    552                              size_rem      -=  sizeof(CPU_INT08U);
   \   00000046   0x1E52             SUBS     R2,R2,#+1
    553                              i--;
   \   00000048   0x1E64             SUBS     R4,R4,#+1
    554                          }
   \   0000004A   0x2A00             CMP      R2,#+0
   \   0000004C   0xD1F4             BNE      ??Mem_Move_5
    555                      }
    556          
    557                                                                          /* See Note #3a.                                        */
    558                      pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
   \                     ??Mem_Move_4: (+1)
   \   0000004E   0x1EC0             SUBS     R0,R0,#+3
    559                      pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
   \   00000050   0x1EC9             SUBS     R1,R1,#+3
   \   00000052   0x2A04             CMP      R2,#+4
   \   00000054   0xD306             BCC      ??Mem_Move_6
    560                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    561                         *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
   \                     ??Mem_Move_7: (+1)
   \   00000056   0x680B             LDR      R3,[R1, #+0]
   \   00000058   0x6003             STR      R3,[R0, #+0]
   \   0000005A   0x1F09             SUBS     R1,R1,#+4
   \   0000005C   0x1F00             SUBS     R0,R0,#+4
    562                          size_rem         -=  sizeof(CPU_ALIGN);
   \   0000005E   0x1F12             SUBS     R2,R2,#+4
    563                      }
   \   00000060   0x2A04             CMP      R2,#+4
   \   00000062   0xD2F8             BCS      ??Mem_Move_7
    564          
    565                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
   \                     ??Mem_Move_6: (+1)
   \   00000064   0x1CC0             ADDS     R0,R0,#+3
    566                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
   \   00000066   0x1CC9             ADDS     R1,R1,#+3
    567          
    568                  }
    569              }
    570          
    571              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
   \                     ??Mem_Move_8: (+1)
   \   00000068   0x2A00             CMP      R2,#+0
   \   0000006A   0xD005             BEQ      ??Mem_Move_1
    572                 *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
   \                     ??Mem_Move_3: (+1)
   \   0000006C   0x780B             LDRB     R3,[R1, #+0]
   \   0000006E   0x7003             STRB     R3,[R0, #+0]
   \   00000070   0x1E49             SUBS     R1,R1,#+1
   \   00000072   0x1E40             SUBS     R0,R0,#+1
    573                  size_rem      -=  sizeof(CPU_INT08U);
   \   00000074   0x1E52             SUBS     R2,R2,#+1
   \   00000076   0xE7F7             B        ??Mem_Move_8
    574              }
    575          }
   \                     ??Mem_Move_1: (+1)
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
    576          
    577          
    578          /*$PAGE*/
    579          /*
    580          *********************************************************************************************************
    581          *                                              Mem_Cmp()
    582          *
    583          * Description : Verify that ALL data octets in two memory buffers are identical in sequence.
    584          *
    585          * Argument(s) : p1_mem      Pointer to first  memory buffer.
    586          *
    587          *               p2_mem      Pointer to second memory buffer.
    588          *
    589          *               size        Number of data buffer octets to compare (see Note #1).
    590          *
    591          * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
    592          *
    593          *               DEF_NO,  otherwise.
    594          *
    595          * Caller(s)   : Application.
    596          *
    597          * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
    598          *                   identical null compare.
    599          *
    600          *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
    601          *                   network address buffers.  Consequently, memory buffer comparison is more efficient
    602          *                   if the comparison starts from the end of the memory buffers which will abort sooner
    603          *                   on dissimilar memory buffers that vary only in the least significant octets.
    604          *
    605          *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
    606          *                   data words.
    607          *
    608          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    609          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    610          *                       addresses.
    611          *
    612          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    613          *                   address boundary.
    614          *
    615          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    616          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    617          *                  'mem_align_mod' arithmetic operation.
    618          *********************************************************************************************************
    619          */
    620          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    621          CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
    622                                const  void        *p2_mem,
    623                                       CPU_SIZE_T   size)
    624          {
   \                     Mem_Cmp: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    625                     CPU_SIZE_T    size_rem;
    626                     CPU_ALIGN    *p1_mem_align;
    627                     CPU_ALIGN    *p2_mem_align;
    628              const  CPU_INT08U   *p1_mem_08;
    629              const  CPU_INT08U   *p2_mem_08;
    630                     CPU_DATA      i;
    631                     CPU_DATA      mem_align_mod_1;
    632                     CPU_DATA      mem_align_mod_2;
    633                     CPU_BOOLEAN   mem_aligned;
    634                     CPU_BOOLEAN   mem_cmp;
    635          
    636          
    637              if (size < 1) {                                             /* See Note #1.                                         */
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE      ??Mem_Cmp_0
    638                  return (DEF_YES);
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE034             B        ??Mem_Cmp_1
    639              }
    640              if (p1_mem == (void *)0) {
   \                     ??Mem_Cmp_0: (+1)
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD031             BEQ      ??Mem_Cmp_2
    641                  return (DEF_NO);
    642              }
    643              if (p2_mem == (void *)0) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD02F             BEQ      ??Mem_Cmp_2
    644                  return (DEF_NO);
    645              }
    646          
    647          
    648              mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
   \   00000014   0x2001             MOVS     R0,#+1
    649              size_rem        =  size;
    650                                                                          /* Start @ end of mem bufs (see Note #2).               */
    651              p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
   \   00000016   0x189B             ADDS     R3,R3,R2
    652              p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
   \   00000018   0x188C             ADDS     R4,R1,R2
    653                                                                          /* See Note #4.                                         */
    654              mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
   \   0000001A   0x2503             MOVS     R5,#+3
   \   0000001C   0x0019             MOVS     R1,R3
   \   0000001E   0x4029             ANDS     R1,R1,R5
    655              mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
    656          
    657              mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
   \   00000020   0x4025             ANDS     R5,R5,R4
   \   00000022   0x42A9             CMP      R1,R5
   \   00000024   0xD11E             BNE      ??Mem_Cmp_3
    658          
    659              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
    660                                                                          /* ... optimize cmp for mem buf alignment.              */
    661                  if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD00E             BEQ      ??Mem_Cmp_4
    662                      i = mem_align_mod_1;
    663                      while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
    664                             (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
    665                             (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
    666                          p1_mem_08--;
   \                     ??Mem_Cmp_5: (+1)
   \   0000002A   0x1E5B             SUBS     R3,R3,#+1
    667                          p2_mem_08--;
   \   0000002C   0x1E64             SUBS     R4,R4,#+1
    668                          if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   0000002E   0x781D             LDRB     R5,[R3, #+0]
   \   00000030   0x7826             LDRB     R6,[R4, #+0]
   \   00000032   0x42B5             CMP      R5,R6
   \   00000034   0xD000             BEQ      ??Mem_Cmp_6
    669                               mem_cmp = DEF_NO;
   \   00000036   0x2000             MOVS     R0,#+0
    670                          }
    671                          size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_6: (+1)
   \   00000038   0x1E52             SUBS     R2,R2,#+1
    672                          i--;
   \   0000003A   0x1E49             SUBS     R1,R1,#+1
    673                      }
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD01A             BEQ      ??Mem_Cmp_1
   \   00000040   0x2A00             CMP      R2,#+0
   \   00000042   0xD001             BEQ      ??Mem_Cmp_4
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD1F0             BNE      ??Mem_Cmp_5
    674                  }
    675          
    676                  if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
    677                      p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
    678                      p2_mem_align = (CPU_ALIGN *)p2_mem_08;
   \                     ??Mem_Cmp_4: (+1)
   \   00000048   0x2A04             CMP      R2,#+4
   \   0000004A   0xD307             BCC      ??Mem_Cmp_7
    679          
    680                      while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
    681                             (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
    682                          p1_mem_align--;
   \   0000004C   0x1F1B             SUBS     R3,R3,#+4
    683                          p2_mem_align--;
   \   0000004E   0x1F24             SUBS     R4,R4,#+4
    684                          if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   00000050   0x1F12             SUBS     R2,R2,#+4
   \   00000052   0x6819             LDR      R1,[R3, #+0]
   \   00000054   0x6825             LDR      R5,[R4, #+0]
   \   00000056   0x42A9             CMP      R1,R5
   \   00000058   0xD0F6             BEQ      ??Mem_Cmp_4
    685                               mem_cmp = DEF_NO;
   \   0000005A   0x2000             MOVS     R0,#+0
    686                          }
    687                          size_rem -= sizeof(CPU_ALIGN);
    688                      }
    689          
    690                      p1_mem_08 = (CPU_INT08U *)p1_mem_align;
    691                      p2_mem_08 = (CPU_INT08U *)p2_mem_align;
    692                  }
    693              }
    694          
    695              while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
    696                     (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
   \                     ??Mem_Cmp_7: (+1)
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD00A             BEQ      ??Mem_Cmp_1
   \                     ??Mem_Cmp_8: (+1)
   \   00000060   0x2A00             CMP      R2,#+0
   \   00000062   0xD008             BEQ      ??Mem_Cmp_1
    697                  p1_mem_08--;
   \                     ??Mem_Cmp_3: (+1)
   \   00000064   0x1E5B             SUBS     R3,R3,#+1
    698                  p2_mem_08--;
   \   00000066   0x1E64             SUBS     R4,R4,#+1
    699                  if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   00000068   0x7819             LDRB     R1,[R3, #+0]
   \   0000006A   0x7825             LDRB     R5,[R4, #+0]
   \   0000006C   0x42A9             CMP      R1,R5
   \   0000006E   0xD101             BNE      ??Mem_Cmp_2
   \   00000070   0x1E52             SUBS     R2,R2,#+1
   \   00000072   0xE7F5             B        ??Mem_Cmp_8
    700                       mem_cmp = DEF_NO;
   \                     ??Mem_Cmp_2: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
    701                  }
    702                  size_rem -= sizeof(CPU_INT08U);
    703              }
    704          
    705              return (mem_cmp);
   \                     ??Mem_Cmp_1: (+1)
   \   00000076   0xBC70             POP      {R4-R6}
   \   00000078   0x4770             BX       LR               ;; return
    706          }
    707          
    708          
    709          /*$PAGE*/
    710          /*
    711          *********************************************************************************************************
    712          *                                           Mem_HeapAlloc()
    713          *
    714          * Description : Allocate a memory block from the heap memory pool.
    715          *
    716          * Argument(s) : size            Size      of memory block to allocate (in octets).
    717          *
    718          *               align           Alignment of memory block to specific word boundary (in octets).
    719          *
    720          *               poctets_reqd    Optional pointer to a variable to ... :
    721          *
    722          *                                   (a) Return the number of octets required to successfully
    723          *                                           allocate the memory block, if any error(s);
    724          *                                   (b) Return 0, otherwise.
    725          *
    726          *               perr        Pointer to variable that will receive the return error code from this function :
    727          *
    728          *                               LIB_MEM_ERR_NONE                Memory block successfully returned.
    729          *                               LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory size.
    730          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    731          *                               LIB_MEM_ERR_HEAP_EMPTY          Heap segment empty; NOT enough available
    732          *                                                                   memory from heap.
    733          *                               LIB_MEM_ERR_HEAP_OVF            Requested memory overflows heap memory.
    734          *
    735          * Return(s)   : Pointer to memory block, if NO error(s).
    736          *
    737          *               Pointer to NULL,         otherwise.
    738          *
    739          * Caller(s)   : Application.
    740          *
    741          * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
    742          *                   validation or function handling in case of any error(s).
    743          *
    744          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
    745          *********************************************************************************************************
    746          */
    747          /*$PAGE*/
    748          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    749          void  *Mem_HeapAlloc (CPU_SIZE_T   size,
    750                                CPU_SIZE_T   align,
    751                                CPU_SIZE_T  *poctets_reqd,
    752                                LIB_ERR     *perr)
    753          {
    754              MEM_POOL    *pmem_pool_heap;
    755              void        *pmem_addr;
    756              void        *pmem_blk;
    757              CPU_SIZE_T   octets_reqd_unused;
    758              CPU_SIZE_T   size_rem;
    759              CPU_SIZE_T   size_req;
    760              CPU_SR_ALLOC();
    761          
    762          
    763          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    764              if (perr == (LIB_ERR *)0) {
    765                  CPU_SW_EXCEPTION((void *)0);
    766              }
    767          #endif
    768          
    769                                                                              /* ------------ VALIDATE RTN OCTETS PTR ----------- */
    770              if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
    771                  poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
    772                 (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
    773              }
    774             *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #1).         */
    775          
    776          
    777          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------ VALIDATE HEAP MEM ALLOC ----------- */
    778              if (size < 1) {
    779                 *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
    780                  return ((void *)0);
    781              }
    782          
    783              if (align < 1) {
    784                 *perr = LIB_MEM_ERR_INVALID_MEM_ALIGN;
    785                  return ((void *)0);
    786              }
    787          #endif
    788          
    789                                                                              /* -------------- ALLOC HEAP MEM BLK -------------- */
    790              pmem_pool_heap = &Mem_PoolHeap;
    791          
    792              CPU_CRITICAL_ENTER();
    793          
    794              pmem_addr = pmem_pool_heap->SegAddrNextAvail;
    795              size_rem  = pmem_pool_heap->SegSizeRem;
    796              size_req  = Mem_SegCalcTotSize(pmem_addr,
    797                                             1u,                              /* Calc alloc for single mem blk from heap.         */
    798                                             size,
    799                                             align);
    800          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    801              if (size_req < 1) {                                             /* If req'd size ovf, ...                           */
    802                  CPU_CRITICAL_EXIT();
    803                 *poctets_reqd = size;                                        /* ... rtn add'l heap size needed.                  */
    804                 *perr         = LIB_MEM_ERR_HEAP_OVF;
    805                  return ((void *)0);
    806              }
    807          #endif
    808          
    809              if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
    810                  CPU_CRITICAL_EXIT();
    811                 *poctets_reqd = size_req - size_rem;                         /* ... rtn add'l heap size needed.                  */
    812                 *perr         = LIB_MEM_ERR_HEAP_EMPTY;
    813                  return ((void *)0);
    814              }
    815          
    816              pmem_blk = Mem_SegAlloc(pmem_pool_heap, size, align);
    817              if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
    818                  CPU_CRITICAL_EXIT();
    819                 *poctets_reqd = size_req;                                    /* ... rtn add'l heap size needed.                  */
    820                 *perr         = LIB_MEM_ERR_HEAP_EMPTY;
    821                  return ((void *)0);
    822              }
    823          
    824              CPU_CRITICAL_EXIT();
    825          
    826             *perr =  LIB_MEM_ERR_NONE;
    827          
    828              return (pmem_blk);
    829          }
    830          #endif
    831          
    832          
    833          /*$PAGE*/
    834          /*
    835          *********************************************************************************************************
    836          *                                        Mem_HeapGetSizeRem()
    837          *
    838          * Description : Get remaining heap memory size available to allocate.
    839          *
    840          * Argument(s) : align       Desired word boundary alignment (in octets) to return remaining memory size from.
    841          *
    842          *               perr        Pointer to variable that will receive the return error code from this function :
    843          *
    844          *                                                               ---- RETURNED BY Mem_PoolGetSizeRem() : ----
    845          *                               LIB_MEM_ERR_NONE                Heap memory pool remaining size successfully
    846          *                                                                   returned.
    847          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    848          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
    849          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    850          *
    851          * Return(s)   : Remaining heap memory size (in octets), if NO error(s).
    852          *
    853          *               0,                                      otherwise.
    854          *
    855          * Caller(s)   : Application.
    856          *
    857          * Note(s)     : none.
    858          *********************************************************************************************************
    859          */
    860          
    861          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    862          CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
    863                                          LIB_ERR     *perr)
    864          {
    865              CPU_SIZE_T  size_rem;
    866          
    867          
    868              size_rem = Mem_SegGetSizeRem(&Mem_PoolHeap, align, perr);
    869          
    870              return (size_rem);
    871          }
    872          #endif
    873          
    874          
    875          /*$PAGE*/
    876          /*
    877          *********************************************************************************************************
    878          *                                         Mem_SegGetSizeRem()
    879          *
    880          * Description : Get memory pool's remaining segment size available to allocate.
    881          *
    882          * Argument(s) : pmem_pool   Pointer to a memory pool structure.
    883          *
    884          *               align       Desired word boundary alignment (in octets) to return remaining memory size from.
    885          *
    886          *               perr        Pointer to variable that will receive the return error code from this function :
    887          *
    888          *                               LIB_MEM_ERR_NONE                Memory segment remaining size successfully
    889          *                                                                   returned.
    890          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    891          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
    892          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    893          *
    894          * Return(s)   : Remaining memory segment size (in octets) [see Note #1], if NO error(s).
    895          *
    896          *               0,                                                       otherwise.
    897          *
    898          * Caller(s)   : Application.
    899          *
    900          * Note(s)     : (1) Remaining size of memory segment returned from either :
    901          *
    902          *                   (a) Segment's configured dedicated memory, if any
    903          *                   (b) Heap memory pool,                      otherwise
    904          *
    905          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
    906          *********************************************************************************************************
    907          */
    908          /*$PAGE*/
    909          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    910          CPU_SIZE_T  Mem_SegGetSizeRem (MEM_POOL    *pmem_pool,
    911                                         CPU_SIZE_T   align,
    912                                         LIB_ERR     *perr)
    913          {
    914              MEM_POOL    *pmem_seg;
    915              MEM_POOL    *pmem_seg_size;
    916              CPU_SIZE_T   size_rem;
    917              CPU_SIZE_T   size_rem_mod;
    918              CPU_SIZE_T   seg_addr_mod;
    919              CPU_ADDR     seg_addr;
    920              CPU_SR_ALLOC();
    921          
    922          
    923          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    924                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
    925              if (perr == (LIB_ERR *)0) {
    926                  CPU_SW_EXCEPTION(0u);
    927              }
    928                                                                          /* ---------------- VALIDATE MEM ALIGN ---------------- */
    929              if (align < 1) {
    930                 *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
    931                  return (0u);
    932              }
    933          	if (align > DEF_ALIGN_MAX_NBR_OCTETS) {
    934          	   *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
    935                  return (0u);
    936              }
    937                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
    938              if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
    939                 *perr =  LIB_MEM_ERR_NULL_PTR;
    940                  return (0u);
    941              }
    942          #endif
    943          
    944              CPU_CRITICAL_ENTER();
    945          
    946          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    947              switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
    948                  case LIB_MEM_TYPE_HEAP:
    949                  case LIB_MEM_TYPE_POOL:
    950                       break;
    951          
    952          
    953                  case LIB_MEM_TYPE_NONE:
    954                  default:
    955                       CPU_CRITICAL_EXIT();
    956                      *perr =  LIB_MEM_ERR_INVALID_POOL;
    957                       return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
    958              }
    959          #endif
    960          
    961                                                                          /* ------------- GET REM'ING MEM SEG SIZE ------------- */
    962              pmem_seg      =  pmem_pool->SegHeadPtr;                     /* Get mem pool's head seg.                             */
    963              pmem_seg_size = (pmem_seg->SegAddr != (void *)0)
    964                            ?  pmem_seg : &Mem_PoolHeap;                  /* See Note #1.                                         */
    965              size_rem      =  pmem_seg_size->SegSizeRem;                 /* Get mem seg's rem'ing mem size.                      */
    966              seg_addr      = (CPU_ADDR)pmem_seg_size->SegAddrNextAvail;
    967          
    968              CPU_CRITICAL_EXIT();
    969          
    970              if (align > 1) {                                            /* If align > 1 octet, ...                              */
    971                  seg_addr_mod  =  seg_addr % align;
    972                  size_rem_mod  = (seg_addr_mod > 0u) ? (align - seg_addr_mod) : 0u;
    973                  size_rem     -=  size_rem_mod;                          /* ... adj rem'ing size by offset to align'd seg addr.  */
    974              }
    975          
    976          
    977             *perr =  LIB_MEM_ERR_NONE;
    978          
    979              return (size_rem);
    980          }
    981          #endif
    982          
    983          
    984          /*$PAGE*/
    985          /*
    986          *********************************************************************************************************
    987          *                                            Mem_PoolClr()
    988          *
    989          * Description : Clear a memory pool (see Note #1).
    990          *
    991          * Argument(s) : pmem_pool   Pointer to a memory pool structure to clear (see Note #2).
    992          *
    993          *               perr        Pointer to variable that will receive the return error code from this function :
    994          *
    995          *                               LIB_MEM_ERR_NONE                Memory pool successfully cleared.
    996          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    997          *
    998          * Return(s)   : none.
    999          *
   1000          * Caller(s)   : Application,
   1001          *               Mem_PoolCreate().
   1002          *
   1003          * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
   1004          *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
   1005          *
   1006          *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
   1007          *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
   1008          *                       this will likely corrupt the memory pool management.
   1009          *
   1010          *               (2) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
   1011          *********************************************************************************************************
   1012          */
   1013          
   1014          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1015          void  Mem_PoolClr (MEM_POOL  *pmem_pool,
   1016                             LIB_ERR   *perr)
   1017          {
   1018          
   1019          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
   1020              if (perr == (LIB_ERR *)0) {
   1021                  CPU_SW_EXCEPTION(;);
   1022              }
   1023          #endif
   1024          
   1025                                                                          /* -------------- VALIDATE MEM POOL PTR --------------- */
   1026              if (pmem_pool == (MEM_POOL *)0) {
   1027                 *perr = LIB_MEM_ERR_NULL_PTR;
   1028                  return;
   1029              }
   1030          
   1031          
   1032              pmem_pool->Type             = (LIB_MEM_TYPE)LIB_MEM_TYPE_NONE;
   1033              pmem_pool->SegHeadPtr       = (MEM_POOL   *)0;
   1034              pmem_pool->SegPrevPtr       = (MEM_POOL   *)0;
   1035              pmem_pool->SegNextPtr       = (MEM_POOL   *)0;
   1036              pmem_pool->PoolPrevPtr      = (MEM_POOL   *)0;
   1037              pmem_pool->PoolNextPtr      = (MEM_POOL   *)0;
   1038              pmem_pool->PoolAddrStart    = (void       *)0;
   1039              pmem_pool->PoolAddrEnd      = (void       *)0;
   1040              pmem_pool->PoolPtrs         = (void      **)0;
   1041              pmem_pool->PoolSize         = (CPU_SIZE_T  )0u;
   1042              pmem_pool->BlkAlign         = (CPU_SIZE_T  )0u;
   1043              pmem_pool->BlkSize          = (CPU_SIZE_T  )0u;
   1044              pmem_pool->BlkNbr           = (CPU_SIZE_T  )0u;
   1045              pmem_pool->BlkIx            = (MEM_POOL_IX )0u;
   1046              pmem_pool->SegAddr          = (void       *)0;
   1047              pmem_pool->SegAddrNextAvail = (void       *)0;
   1048              pmem_pool->SegSizeTot       = (CPU_SIZE_T  )0u;
   1049              pmem_pool->SegSizeRem       = (CPU_SIZE_T  )0u;
   1050          
   1051          
   1052             *perr = LIB_MEM_ERR_NONE;
   1053          }
   1054          #endif
   1055          
   1056          
   1057          /*$PAGE*/
   1058          /*
   1059          *********************************************************************************************************
   1060          *                                          Mem_PoolCreate()
   1061          *
   1062          * Description : (1) Create a memory pool :
   1063          *
   1064          *                   (a) Create    memory pool from heap or dedicated memory
   1065          *                   (b) Allocate  memory pool memory blocks
   1066          *                   (c) Update    memory pool table
   1067          *                   (d) Configure memory pool
   1068          *
   1069          *
   1070          *               (2) Memory pools are indexed by the Memory Segments they use.
   1071          *
   1072          *                   (a) The memory pool table is composed by a two-dimensional list :
   1073          *
   1074          *                       (1) Memory segments manage the following memory segment/pool information :
   1075          *
   1076          *                           (A) Memory segment base           address
   1077          *                           (B) Memory segment next available address
   1078          *                           (C) Memory segment total     size
   1079          *                           (D) Memory segment remaining size
   1080          *
   1081          *                       (2) Memory pools share memory from memory segments but do NOT manage any memory
   1082          *                           segment information.  To access the memory segment information, the head
   1083          *                           memory segment must be accessed via each memory pool's 'SegHeadPtr'.
   1084          *
   1085          *                   (b) In the diagram below, memory pools in vertical columns represent they share the same
   1086          *                       memory segment for the memory blocks they have.  The heads of the memory pool are
   1087          *                       linked horizontally to form a memory pool table.
   1088          *
   1089          *                       (1) 'Mem_PoolTbl' points to the head of the Memory Pool table.
   1090          *
   1091          *                       (2) Memory Pools' 'SegPrevPtr'  & 'SegNextPtr'  doubly-link each memory segment to
   1092          *                           form the list of memory segments.
   1093          *
   1094          *                       (3) Memory Pools' 'PoolPrevPtr' & 'PoolNextPtr' doubly-link the  memory pools of
   1095          *                           each memory segment.
   1096          *
   1097          *                   (c) New memory pools, which do not share a memory segment, are inserted in the Memory
   1098          *                       Segments Primary List.  The point of insertion is such to keep ascended order by
   1099          *                       memory segment base address.
   1100          *
   1101          *                   (d) Memory pool pointers to memory blocks 'PoolPtrs' must be allocated for each created
   1102          *                       memory pool.  These pointers are stored in the memory pool heap segment 'Mem_PoolHeap'.
   1103          *
   1104          *                       (1) A memory pool can also have its memory blocks allocated from the memory pool heap.
   1105          *                           'pmem_base_addr' must be set to NULL & 'mem_size' must be set to (0) to create the
   1106          *                           memory pool.
   1107          *
   1108          *
   1109          *                                        |                                                                 |
   1110          *                                        |<----------------------- Memory Segments ----------------------->|
   1111          *                                        |                         (see Note #2a1)                         |
   1112          *
   1113          *                                 Lowest Memory Segment                                      Highest Memory Segment
   1114          *                                     Base Address                                                Base Address
   1115          *                                    (see Note #2c)                                              (see Note #2c)
   1116          *
   1117          *                                           |             SegNextPtr             Heap Memory Pool       |
   1118          *                                           |          (see Note #2b2)            (see Note #2d)        |
   1119          *                                           |                     |                                     |
   1120          *                                           v                     |                      |              v
   1121          *                                                                 |                      v
   1122          *        ---          Head of Memory     -------        -------   v    -------        -------        -------
   1123          *         ^             Pool Table   --->|     |------->|     |------->|     |------->|     |------->|     |
   1124          *         |          (see Note #2b1)     |     |        |     |        |     |        |  H  |        |     |
   1125          *         |                              |     |<-------|     |<-------|     |<-------|  E  |<-------|     |
   1126          *         |                              |     |        |     |   ^    |     |        |  A  |        |     |
   1127          *         |                              |     |        |     |   |    |     |        |  P  |        |     |
   1128          *         |                              |     |        |     |   |    |     |        |     |        |     |
   1129          *         |                              -------        -------   |    -------        -------        -------
   1130          *         |                                | ^                    |      | ^
   1131          *         |                                | |            SegPrevPtr     | |
   1132          *         |                                v |         (see Note #2b2)   v |
   1133          *         |                              -------                       -------
   1134          *                                        |     |                       |     |
   1135          *    Memory Pools                        |     |                       |     |
   1136          *  (see Note #2a2)                       |     |                       |     |
   1137          *                                        |     |                       |     |
   1138          *         |                              |     |                       |     |
   1139          *         |                              -------                       -------
   1140          *         |                                | ^
   1141          *         |               PoolNextPtr ---> | | <--- PoolPrevPtr
   1142          *         |             (see Note #2b3)    v |    (see Note #2b3)
   1143          *         |                              -------
   1144          *         |                              |     |
   1145          *         |                              |     |
   1146          *         |                              |     |
   1147          *         |                              |     |
   1148          *         v                              |     |
   1149          *        ---                             -------
   1150          *
   1151          *$PAGE*
   1152          * Argument(s) : pmem_pool           Pointer to a memory pool structure to create (see Note #3).
   1153          *
   1154          *               pmem_base_addr      Memory pool base address :
   1155          *
   1156          *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
   1157          *                                       (b) Non-null address    Memory pool allocated from dedicated memory
   1158          *                                                                   specified by its base address.
   1159          *
   1160          *               mem_size            Size      of memory pool segment          (in octets).
   1161          *
   1162          *               blk_nbr             Number    of memory pool blocks to create.
   1163          *
   1164          *               blk_size            Size      of memory pool blocks to create (in octets).
   1165          *
   1166          *               blk_align           Alignment of memory pool blocks to specific word boundary (in octets).
   1167          *
   1168          *               poctets_reqd        Optional pointer to a variable to ... :
   1169          *
   1170          *                                       (a) Return the number of octets required to successfully
   1171          *                                               allocate the memory pool, if any error(s);
   1172          *                                       (b) Return 0, otherwise.
   1173          *
   1174          *               perr        Pointer to variable that will receive the return error code from this function :
   1175          *
   1176          *                               LIB_MEM_ERR_NONE                    Memory pool successfully created.
   1177          *
   1178          *                               LIB_MEM_ERR_HEAP_NOT_FOUND          Heap   segment NOT found.
   1179          *                               LIB_MEM_ERR_HEAP_EMPTY              Heap   segment empty; NOT enough available
   1180          *                                                                       memory from heap.
   1181          *                               LIB_MEM_ERR_HEAP_OVF                Requested memory overflows heap    memory.
   1182          *                               LIB_MEM_ERR_SEG_EMPTY               Memory segment empty; NOT enough available
   1183          *                                                                       memory from segment for memory pools.
   1184          *                               LIB_MEM_ERR_SEG_OVF                 Requested memory overflows segment memory.
   1185          *
   1186          *                               LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid memory segment size.
   1187          *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Memory segment overlaps other memory
   1188          *                                                                       segment(s) in memory pool table.
   1189          *                               LIB_MEM_ERR_INVALID_BLK_NBR         Invalid memory pool number of blocks.
   1190          *                               LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid memory pool block size.
   1191          *                               LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid memory pool block alignment.
   1192          *
   1193          *                                                                   ------- RETURNED BY Mem_PoolClr() : -------
   1194          *                               LIB_MEM_ERR_NULL_PTR                Argument 'pmem_pool' passed a NULL pointer.
   1195          *
   1196          * Return(s)   : none.
   1197          *
   1198          * Caller(s)   : Application.
   1199          *
   1200          * Note(s)     : (3) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
   1201          *
   1202          *               (4) Pointers to variables that return values MUST be initialized PRIOR to all other
   1203          *                   validation or function handling in case of any error(s).
   1204          *
   1205          *               (5) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1206          *********************************************************************************************************
   1207          */
   1208          /*$PAGE*/
   1209          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1210          void  Mem_PoolCreate (MEM_POOL          *pmem_pool,
   1211                                void              *pmem_base_addr,
   1212                                CPU_SIZE_T         mem_size,
   1213                                MEM_POOL_BLK_QTY   blk_nbr,
   1214                                CPU_SIZE_T         blk_size,
   1215                                CPU_SIZE_T         blk_align,
   1216                                CPU_SIZE_T        *poctets_reqd,
   1217                                LIB_ERR           *perr)
   1218          {
   1219              MEM_POOL           *pmem_pool_heap;
   1220              MEM_POOL           *pmem_pool_next;
   1221              MEM_POOL           *pmem_seg;
   1222              MEM_POOL           *pmem_seg_prev;
   1223              MEM_POOL           *pmem_seg_next;
   1224              void              **ppool_ptr;
   1225              void               *pmem_blk;
   1226              CPU_INT08U         *pmem_addr_ptrs;
   1227              CPU_INT08U         *pmem_addr_pool;
   1228              CPU_INT08U         *pmem_base_addr_start;
   1229              CPU_INT08U         *pmem_base_addr_end;
   1230              CPU_INT08U         *pmem_seg_addr_start;
   1231              CPU_INT08U         *pmem_seg_addr_end;
   1232              MEM_POOL_BLK_QTY    blk_rem;
   1233              CPU_SIZE_T          octets_reqd_unused;
   1234              CPU_SIZE_T          size_tot;
   1235              CPU_SIZE_T          size_tot_ptrs;
   1236              CPU_SIZE_T          size_tot_pool;
   1237              CPU_SIZE_T          size_rem;
   1238              CPU_SIZE_T          size_pool_ptrs;
   1239              CPU_SIZE_T          i;
   1240              CPU_SR_ALLOC();
   1241          
   1242          
   1243          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1244              if (perr == (LIB_ERR *)0) {
   1245                  CPU_SW_EXCEPTION(;);
   1246              }
   1247          #endif
   1248          
   1249                                                                              /* ------------ VALIDATE RTN OCTETS PTR ----------- */
   1250              if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
   1251                  poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
   1252                 (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
   1253              }
   1254             *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #4).         */
   1255          
   1256          
   1257          
   1258              Mem_PoolClr(pmem_pool, perr);                                   /* Init mem pool     for err (see Note #4).         */
   1259              if (*perr != LIB_MEM_ERR_NONE) {
   1260                   return;
   1261              }
   1262          
   1263          
   1264                                                                              /* ----------- VALIDATE MEM POOL CREATE ----------- */
   1265          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1266              if (pmem_base_addr != (void *)0) {
   1267                  if (mem_size < 1) {
   1268                     *perr = LIB_MEM_ERR_INVALID_SEG_SIZE;
   1269                      return;
   1270                  }
   1271              }
   1272          
   1273              if (blk_nbr < 1) {
   1274                 *perr = LIB_MEM_ERR_INVALID_BLK_NBR;
   1275                  return;
   1276              }
   1277          
   1278              if (blk_size < 1) {
   1279                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1280                  return;
   1281              }
   1282          
   1283              if (blk_align < 1) {
   1284                 *perr = LIB_MEM_ERR_INVALID_BLK_ALIGN;
   1285                  return;
   1286              }
   1287          #endif
   1288          
   1289          
   1290                                                                              /* ------------ VALIDATE MEM POOL TBL ------------- */
   1291              if (Mem_PoolTbl == (MEM_POOL *)0) {
   1292                 *perr = LIB_MEM_ERR_HEAP_NOT_FOUND;
   1293                  return;
   1294              }
   1295          
   1296          
   1297          
   1298          /*$PAGE*/
   1299                                                                              /* ---------------- CREATE MEM POOL --------------- */
   1300              pmem_pool_heap = (MEM_POOL *)&Mem_PoolHeap;
   1301              size_tot       = (CPU_SIZE_T) 0u;
   1302          
   1303              CPU_CRITICAL_ENTER();
   1304          
   1305              if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
   1306                  pmem_seg        =  pmem_pool_heap;
   1307                  pmem_seg_prev   =  pmem_pool_heap;
   1308                  pmem_seg_next   =  pmem_pool_heap;
   1309          
   1310                                                                              /* --------------- VALIDATE MEM SEG --------------- */
   1311                                                                              /* Calc tot mem   size for mem pool ptrs.           */
   1312                  pmem_addr_ptrs  = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
   1313                  size_tot_ptrs   =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
   1314                                                        (CPU_SIZE_T)blk_nbr,
   1315                                                        (CPU_SIZE_T)sizeof(void *),
   1316                                                        (CPU_SIZE_T)sizeof(void *));
   1317          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1318                  if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
   1319                      CPU_CRITICAL_EXIT();
   1320                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1321                      return;
   1322                  }
   1323          #endif
   1324                                                                              /* Calc tot mem   size for mem blks.                */
   1325                  pmem_addr_pool  =  pmem_addr_ptrs + size_tot_ptrs;          /* Adj next avail addr for mem pool blks.           */
   1326                  size_tot_pool   =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
   1327                                                        (CPU_SIZE_T)blk_nbr,
   1328                                                        (CPU_SIZE_T)blk_size,
   1329                                                        (CPU_SIZE_T)blk_align);
   1330          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1331                  if (size_tot_pool < 1) {                                    /* If heap ovf, ...                                 */
   1332                      CPU_CRITICAL_EXIT();
   1333                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1334                      return;
   1335                  }
   1336          #endif
   1337          
   1338                  size_tot = size_tot_ptrs + size_tot_pool;
   1339          
   1340          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1341                  if ((size_tot < size_tot_ptrs) ||                           /* If heap ovf, ...                                 */
   1342                      (size_tot < size_tot_pool)) {
   1343                      CPU_CRITICAL_EXIT();
   1344                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1345                      return;
   1346                  }
   1347          #endif
   1348          
   1349                  size_rem = pmem_pool_heap->SegSizeRem;
   1350                  if (size_tot > size_rem) {                                  /* If tot size > rem  size, ...                     */
   1351                      CPU_CRITICAL_EXIT();
   1352                     *poctets_reqd = size_tot - size_rem;                     /* ... rtn add'l heap size needed.                  */
   1353                     *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   1354                      return;
   1355                  }
   1356          
   1357          /*$PAGE*/
   1358              } else {                                                        /* Else cfg mem pool from dedicated mem.            */
   1359                                                                              /* -------- SRCH ALL MEM SEGS FOR MEM POOL -------- */
   1360                  pmem_base_addr_start = (CPU_INT08U *)pmem_base_addr;
   1361                  pmem_base_addr_end   = (CPU_INT08U *)pmem_base_addr + mem_size - 1;
   1362          
   1363          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1364                  if (pmem_base_addr_end < pmem_base_addr_start) {            /* Chk ovf of end addr.                             */
   1365                      CPU_CRITICAL_EXIT();
   1366                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   1367                      return;
   1368                  }
   1369          #endif
   1370          
   1371                  pmem_seg      = (MEM_POOL *)0;
   1372                  pmem_seg_prev = (MEM_POOL *)0;
   1373                  pmem_seg_next =  Mem_PoolTbl;
   1374          
   1375                  while (pmem_seg_next != (MEM_POOL *)0) {                    /* Srch tbl for mem seg with same base addr/size.   */
   1376          
   1377                      if ((pmem_base_addr == pmem_seg_next->SegAddr) &&       /* If same base addr/size found, ...                */
   1378                          (mem_size       == pmem_seg_next->SegSizeTot)) {
   1379          
   1380                           pmem_seg        = pmem_seg_next;                   /* ... mem seg already avail in tbl.                */
   1381                           break;
   1382          
   1383                      } else {
   1384                          pmem_seg_addr_start = (CPU_INT08U *)pmem_seg_next->SegAddr;
   1385                          pmem_seg_addr_end   = (CPU_INT08U *)pmem_seg_next->SegAddr + pmem_seg_next->SegSizeTot - 1;
   1386          
   1387          
   1388                          if (pmem_base_addr_end < pmem_seg_addr_start) {     /* If mem seg addr/size prior to next mem seg, ...  */
   1389                              break;                                          /* ... new mem seg NOT avail in tbl.                */
   1390          
   1391                                                                              /* If mem seg overlaps prev mem seg(s) in tbl, ...  */
   1392                          } else if (((pmem_base_addr_start <= pmem_seg_addr_start)  &&
   1393                                      (pmem_base_addr_end   >= pmem_seg_addr_start)) ||
   1394                                     ((pmem_base_addr_start >= pmem_seg_addr_start)  &&
   1395                                      (pmem_base_addr_end   <= pmem_seg_addr_end  )) ||
   1396                                     ((pmem_base_addr_start <= pmem_seg_addr_end  )  &&
   1397                                      (pmem_base_addr_end   >= pmem_seg_addr_end  ))) {
   1398                              CPU_CRITICAL_EXIT();
   1399                             *perr = LIB_MEM_ERR_INVALID_SEG_OVERLAP;         /* ... rtn err.                                     */
   1400                              return;
   1401                          }
   1402                      }
   1403                                                                              /* If mem seg NOT found, adv to next mem seg.       */
   1404                      pmem_seg_prev = pmem_seg_next;
   1405                      pmem_seg_next = pmem_seg_next->SegNextPtr;
   1406                  }
   1407          
   1408                  if (pmem_seg == (MEM_POOL *)0) {                            /* If mem seg NOT found, add    new  mem seg.       */
   1409                      pmem_seg                    = pmem_pool;
   1410                      pmem_pool->SegAddr          = pmem_base_addr;
   1411                      pmem_pool->SegAddrNextAvail = pmem_base_addr;
   1412                      pmem_pool->SegSizeTot       = mem_size;
   1413                      pmem_pool->SegSizeRem       = mem_size;
   1414                  }
   1415          
   1416          /*$PAGE*/
   1417                                                                              /* --------------- VALIDATE MEM SEG --------------- */
   1418                                                                              /* Calc tot mem size for mem pool ptrs.             */
   1419                  pmem_addr_ptrs = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
   1420                  size_tot_ptrs  =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
   1421                                                       (CPU_SIZE_T)blk_nbr,
   1422                                                       (CPU_SIZE_T)sizeof(void *),
   1423                                                       (CPU_SIZE_T)sizeof(void *));
   1424          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1425                  if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
   1426                      CPU_CRITICAL_EXIT();
   1427                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1428                      return;
   1429                  }
   1430          #endif
   1431          
   1432                  size_rem = pmem_pool_heap->SegSizeRem;
   1433                  if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
   1434                      CPU_CRITICAL_EXIT();
   1435                     *poctets_reqd = size_tot_ptrs - size_rem;                /* ... rtn add'l heap size needed.                  */
   1436                     *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   1437                      return;
   1438                  }
   1439          
   1440                                                                              /* Calc tot mem size for mem blks.                  */
   1441                  pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
   1442                  size_tot_pool  =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
   1443                                                       (CPU_SIZE_T)blk_nbr,
   1444                                                       (CPU_SIZE_T)blk_size,
   1445                                                       (CPU_SIZE_T)blk_align);
   1446          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1447                  if (size_tot_pool < 1) {                                    /* If seg  ovf, ...                                 */
   1448                      CPU_CRITICAL_EXIT();
   1449                     *perr = LIB_MEM_ERR_SEG_OVF;                             /* ... rtn err but add'l seg  size NOT avail.       */
   1450                      return;
   1451                  }
   1452          #endif
   1453          
   1454                  size_rem = pmem_seg->SegSizeRem;
   1455                  if (size_tot_pool > size_rem) {                             /* If tot size > rem  size, ...                     */
   1456                      CPU_CRITICAL_EXIT();
   1457                     *poctets_reqd = size_tot_pool - size_rem;                /* ... rtn add'l seg  size needed.                  */
   1458                     *perr         = LIB_MEM_ERR_SEG_EMPTY;
   1459                      return;
   1460                  }
   1461              }
   1462          
   1463          
   1464          /*$PAGE*/
   1465                                                                              /* ---------------- ALLOC MEM BLKs ---------------- */
   1466              size_pool_ptrs = (CPU_SIZE_T)(blk_nbr * sizeof(void *));
   1467                                                                              /* Alloc stk of ptrs for mem blks from heap.        */
   1468              ppool_ptr      = (void **)Mem_SegAlloc((MEM_POOL *)pmem_pool_heap,
   1469                                                     (CPU_SIZE_T)size_pool_ptrs,
   1470                                                     (CPU_SIZE_T)sizeof(void *));
   1471              if (ppool_ptr == (void **)0) {                                  /* If mem pool ptrs alloc failed, ...               */
   1472                  size_rem = pmem_pool_heap->SegSizeRem;
   1473                  CPU_CRITICAL_EXIT();
   1474                                                                              /* ... rtn add'l heap size needed.                  */
   1475                  if (pmem_base_addr == (void *)0) {
   1476                      if (size_tot > size_rem) {
   1477                         *poctets_reqd = size_tot - size_rem;
   1478                      } else {
   1479                         *poctets_reqd = size_tot;
   1480                      }
   1481                  } else {
   1482                      if (size_pool_ptrs > size_rem) {
   1483                         *poctets_reqd = size_pool_ptrs - size_rem;
   1484                      } else {
   1485                         *poctets_reqd = size_pool_ptrs;
   1486                      }
   1487                  }
   1488                 *perr = LIB_MEM_ERR_HEAP_EMPTY;
   1489                  return;
   1490              }
   1491          
   1492              for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
   1493                  pmem_blk = (void *)Mem_SegAlloc(pmem_seg, blk_size, blk_align);
   1494                  if (pmem_blk == (void *)0) {                                /* If    mem blks alloc failed, ...                 */
   1495                      pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
   1496                      size_rem       = (CPU_SIZE_T  )pmem_seg->SegSizeRem;
   1497                      CPU_CRITICAL_EXIT();
   1498                      blk_rem        =  blk_nbr - (MEM_POOL_BLK_QTY)i;
   1499                      size_tot       =  Mem_SegCalcTotSize((void           *)pmem_addr_pool,
   1500                                                           (MEM_POOL_BLK_QTY)blk_rem,
   1501                                                           (CPU_SIZE_T      )blk_size,
   1502                                                           (CPU_SIZE_T      )blk_align);
   1503                                                                              /* ... rtn add'l seg  size needed.                  */
   1504                      if (size_tot > size_rem) {
   1505                         *poctets_reqd = size_tot - size_rem;
   1506                      } else {
   1507                         *poctets_reqd = size_tot;
   1508                      }
   1509                     *perr = LIB_MEM_ERR_SEG_EMPTY;
   1510                      return;
   1511                  }
   1512                  ppool_ptr[i] = pmem_blk;
   1513              }
   1514          
   1515          
   1516          /*$PAGE*/
   1517                                                                              /* ------------- UPDATE MEM POOL TBL -------------- */
   1518              if (pmem_seg == pmem_pool) {                                    /* Add mem pool as new  mem pool tbl seg.           */
   1519                                                                              /* Update cur  mem seg  links.                      */
   1520                  pmem_pool->SegPrevPtr = pmem_seg_prev;
   1521                  pmem_pool->SegNextPtr = pmem_seg_next;
   1522          
   1523                  if (pmem_seg_prev != (MEM_POOL *)0) {                       /* Update prev mem seg  link.                       */
   1524                      pmem_seg_prev->SegNextPtr = pmem_pool;
   1525                  } else {
   1526                      Mem_PoolTbl               = pmem_pool;                  /* Update      mem tbl.                             */
   1527                  }
   1528          
   1529                  if (pmem_seg_next != (MEM_POOL *)0) {                       /* Update next mem seg  link.                       */
   1530                      pmem_seg_next->SegPrevPtr = pmem_pool;
   1531                  }
   1532          
   1533              } else {                                                        /* Add mem pool into mem seg.                       */
   1534                                                                              /* Update cur  mem pool links.                      */
   1535                  pmem_pool_next         = pmem_seg->PoolNextPtr;
   1536                  pmem_pool->PoolPrevPtr = pmem_seg;
   1537                  pmem_pool->PoolNextPtr = pmem_pool_next;
   1538          
   1539                  pmem_seg->PoolNextPtr  = pmem_pool;                         /* Update prev mem pool link.                       */
   1540          
   1541                  if (pmem_pool_next != (MEM_POOL *)0) {                      /* Update next mem pool link.                       */
   1542                      pmem_pool_next->PoolPrevPtr = pmem_pool;
   1543                  }
   1544              }
   1545          
   1546          
   1547          
   1548                                                                              /* ----------------- CFG MEM POOL ----------------- */
   1549              pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
   1550              pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
   1551              pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
   1552              pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
   1553              pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
   1554              pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
   1555              pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
   1556              pmem_pool->BlkSize       = (CPU_SIZE_T      ) blk_size;
   1557              pmem_pool->BlkNbr        = (MEM_POOL_BLK_QTY) blk_nbr;
   1558              pmem_pool->BlkIx         = (MEM_POOL_IX     ) blk_nbr;
   1559          
   1560          
   1561              CPU_CRITICAL_EXIT();
   1562          
   1563             *perr = LIB_MEM_ERR_NONE;
   1564          }
   1565          #endif
   1566          
   1567          
   1568          /*$PAGE*/
   1569          /*
   1570          *********************************************************************************************************
   1571          *                                      Mem_PoolBlkGetNbrAvail()
   1572          *
   1573          * Description : Get memory pools remaining number of blocks available to allocate.
   1574          *
   1575          * Argument(s) : pmem_pool   Pointer to a memory pool structure.
   1576          *
   1577          *               perr        Pointer to variable that will receive the return error code from this function :
   1578          *
   1579          *                               LIB_MEM_ERR_NONE                Memory pool available number of blocks
   1580          *                                                                   successfully returned.
   1581          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1582          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1583          *
   1584          * Return(s)   : Remaining memory pool blocks (see Note #1), if NO error(s).
   1585          *
   1586          *               0,                                          otherwise.
   1587          *
   1588          * Caller(s)   : Application.
   1589          *
   1590          * Note(s)     : (1) (a) Mem_PoolBlkGetNbrAvail() ONLY supports non-heap memory pools.
   1591          *                   (b) Mem_HeapGetSizeRem()/Mem_SegGetSizeRem() should be used for heap memory pool/segment.
   1592          *
   1593          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1594          *********************************************************************************************************
   1595          */
   1596          /*$PAGE*/
   1597          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1598          MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *pmem_pool,
   1599                                                    LIB_ERR   *perr)
   1600          {
   1601              MEM_POOL_BLK_QTY  nbr_blk_rem;
   1602              CPU_SR_ALLOC();
   1603          
   1604          
   1605          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1606                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
   1607              if (perr == (LIB_ERR *)0) {
   1608                  CPU_SW_EXCEPTION(0u);
   1609              }
   1610                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
   1611              if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
   1612                 *perr =  LIB_MEM_ERR_NULL_PTR;
   1613                  return (0u);
   1614              }
   1615          #endif
   1616          
   1617              CPU_CRITICAL_ENTER();
   1618          
   1619          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1620              switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
   1621                  case LIB_MEM_TYPE_POOL:
   1622                       break;
   1623          
   1624          
   1625                  case LIB_MEM_TYPE_NONE:
   1626                  case LIB_MEM_TYPE_HEAP:
   1627                  default:
   1628                       CPU_CRITICAL_EXIT();
   1629                      *perr =  LIB_MEM_ERR_INVALID_POOL;
   1630                       return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
   1631              }
   1632          #endif
   1633          
   1634                                                                          /* --------- GET REM'ING MEM POOL NBR BLK(S) ---------- */
   1635              nbr_blk_rem = pmem_pool->BlkIx;
   1636          
   1637              CPU_CRITICAL_EXIT();
   1638          
   1639          
   1640             *perr =  LIB_MEM_ERR_NONE;
   1641          
   1642              return (nbr_blk_rem);
   1643          }
   1644          #endif
   1645          
   1646          
   1647          /*$PAGE*/
   1648          /*
   1649          *********************************************************************************************************
   1650          *                                          Mem_PoolBlkGet()
   1651          *
   1652          * Description : Get a memory block from memory pool.
   1653          *
   1654          * Argument(s) : pmem_pool   Pointer to  memory pool to get memory block from.
   1655          *
   1656          *               size        Size of requested memory (in octets).
   1657          *
   1658          *               perr        Pointer to variable that will receive the return error code from this function :
   1659          *
   1660          *                               LIB_MEM_ERR_NONE                   Memory block successfully returned.
   1661          *                               LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
   1662          *
   1663          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1664          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1665          *                               LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
   1666          *                               LIB_MEM_ERR_INVALID_BLK_IX      Invalid memory pool block index.
   1667          *
   1668          * Return(s)   : Pointer to memory block, if NO error(s).
   1669          *
   1670          *               Pointer to NULL,         otherwise.
   1671          *
   1672          * Caller(s)   : Application.
   1673          *
   1674          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1675          *********************************************************************************************************
   1676          */
   1677          /*$PAGE*/
   1678          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1679          void  *Mem_PoolBlkGet (MEM_POOL    *pmem_pool,
   1680                                 CPU_SIZE_T   size,
   1681                                 LIB_ERR     *perr)
   1682          {
   1683              void  *pmem_blk;
   1684              CPU_SR_ALLOC();
   1685          
   1686          
   1687          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1688              if (perr == (LIB_ERR *)0) {
   1689                  CPU_SW_EXCEPTION((void *)0);
   1690              }
   1691          #endif
   1692          
   1693                                                                              /* ------------ VALIDATE MEM POOL GET ------------- */
   1694          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1695              if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
   1696                 *perr = LIB_MEM_ERR_NULL_PTR;
   1697                  return ((void *)0);
   1698              }
   1699          
   1700              if (size < 1) {                                                 /* Validate req'd size as non-NULL.                 */
   1701                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1702                  return ((void *)0);
   1703              }
   1704          #endif
   1705          
   1706              CPU_CRITICAL_ENTER();
   1707          
   1708          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1709              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   1710                  CPU_CRITICAL_EXIT();
   1711                 *perr = LIB_MEM_ERR_INVALID_POOL;
   1712                  return ((void *)0);
   1713              }
   1714          
   1715              if (size > pmem_pool->BlkSize) {                                /* Validate req'd size <= mem pool blk size.        */
   1716                  CPU_CRITICAL_EXIT();
   1717                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1718                  return ((void *)0);
   1719              }
   1720          #endif
   1721          
   1722             (void)&size;                                                     /* Prevent possible 'variable unused' warning.      */
   1723          
   1724              if (pmem_pool->BlkIx < 1) {                                     /* Validate mem pool as NOT empty.                  */
   1725                  CPU_CRITICAL_EXIT();
   1726                 *perr = LIB_MEM_ERR_POOL_EMPTY;
   1727                  return ((void *)0);
   1728              }
   1729          
   1730              if (pmem_pool->BlkIx > pmem_pool->BlkNbr) {                     /* Validate mem pool ix NOT corrupt.                */
   1731                  CPU_CRITICAL_EXIT();
   1732                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   1733                  return ((void *)0);
   1734              }
   1735          
   1736                                                                              /* ------------ GET MEM BLK FROM POOL ------------- */
   1737              pmem_pool->BlkIx--;
   1738              pmem_blk = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
   1739          
   1740              CPU_CRITICAL_EXIT();
   1741          
   1742             *perr =  LIB_MEM_ERR_NONE;
   1743          
   1744              return (pmem_blk);
   1745          }
   1746          #endif
   1747          
   1748          
   1749          /*$PAGE*/
   1750          /*
   1751          *********************************************************************************************************
   1752          *                                      Mem_PoolBlkGetUsedAtIx()
   1753          *
   1754          * Description : Get a used memory block from memory pool, by index.
   1755          *
   1756          * Argument(s) : pmem_pool   Pointer to memory pool to get memory block from.
   1757          *
   1758          *               used_ix     Index of the used memory block to get.
   1759          *
   1760          *               perr        Pointer to variable that will receive the return error code from this function :
   1761          *
   1762          *                               LIB_MEM_ERR_NONE                    Memory block successfully returned.
   1763          *                               LIB_MEM_ERR_POOL_FULL           All memory blocks available in memory pool.
   1764          *
   1765          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1766          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1767          *                               LIB_MEM_ERR_INVALID_BLK_IX      Invalid memory pool block index.
   1768          *
   1769          * Return(s)   : Pointer to memory block, if NO error(s).
   1770          *
   1771          *               Pointer to NULL,         otherwise.
   1772          *
   1773          * Caller(s)   : Application.
   1774          *
   1775          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1776          *
   1777          *               (2) The returned index can be altered when Mem_PoolBlkFree() is called. This index must
   1778          *                   only be used in conjunction with Mem_PoolBlkGetUsedAtIx() if holding a proper
   1779          *                   lock to avoid the index to be modified.
   1780          *********************************************************************************************************
   1781          */
   1782          /*$PAGE*/
   1783          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1784          void  *Mem_PoolBlkGetUsedAtIx (MEM_POOL          *pmem_pool,
   1785                                         MEM_POOL_IX        used_ix,
   1786                                         LIB_ERR           *perr)
   1787          {
   1788              MEM_POOL_IX   blk_ix;
   1789              void         *pmem_blk;
   1790              CPU_SR_ALLOC();
   1791          
   1792          
   1793          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1794              if (perr == (LIB_ERR *)0) {
   1795                  CPU_SW_EXCEPTION((void *)0);
   1796              }
   1797          #endif
   1798          
   1799                                                                              /* ------------ VALIDATE MEM POOL GET ------------- */
   1800          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1801              if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
   1802                 *perr = LIB_MEM_ERR_NULL_PTR;
   1803                  return ((void *)0);
   1804              }
   1805          #endif
   1806          
   1807              CPU_CRITICAL_ENTER();
   1808          
   1809          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1810              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   1811                  CPU_CRITICAL_EXIT();
   1812                 *perr = LIB_MEM_ERR_INVALID_POOL;
   1813                  return ((void *)0);
   1814              }
   1815          
   1816              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool as NOT full.                   */
   1817                  CPU_CRITICAL_EXIT();
   1818                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   1819                  return ((void *)0);
   1820              }
   1821          #endif
   1822          
   1823              blk_ix = pmem_pool->BlkNbr - used_ix - 1u;
   1824          
   1825              if (blk_ix >= pmem_pool->BlkNbr) {                              /* Validate ix range.                               */
   1826                  CPU_CRITICAL_EXIT();
   1827                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   1828                  return ((void *)0);
   1829              }
   1830          
   1831              if (blk_ix < pmem_pool->BlkIx) {
   1832                  CPU_CRITICAL_EXIT();
   1833                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   1834                  return ((void *)0);
   1835              }
   1836                                                                              /* ------------ GET MEM BLK FROM POOL ------------- */
   1837              pmem_blk = pmem_pool->PoolPtrs[blk_ix];
   1838          
   1839              CPU_CRITICAL_EXIT();
   1840          
   1841             *perr =  LIB_MEM_ERR_NONE;
   1842          
   1843              return (pmem_blk);
   1844          }
   1845          #endif
   1846          
   1847          
   1848          /*$PAGE*/
   1849          /*
   1850          *********************************************************************************************************
   1851          *                                          Mem_PoolBlkFree()
   1852          *
   1853          * Description : Free a memory block to memory pool.
   1854          *
   1855          * Argument(s) : pmem_pool   Pointer to memory pool to free memory block.
   1856          *
   1857          *               pmem_blk    Pointer to memory block address to free.
   1858          *
   1859          *               perr        Pointer to variable that will receive the return error code from this function :
   1860          *
   1861          *                               LIB_MEM_ERR_NONE                            Memory block successfully freed.
   1862          *                               LIB_MEM_ERR_POOL_FULL                   ALL memory blocks already available in
   1863          *                                                                           memory pool.
   1864          *
   1865          *                               LIB_MEM_ERR_NULL_PTR                    Argument 'pmem_pool'/'pmem_blk' passed
   1866          *                                                                           a NULL pointer.
   1867          *                               LIB_MEM_ERR_INVALID_POOL                Invalid memory pool  type.
   1868          *                               LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1869          *                               LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1870          *                                                                            in memory pool.
   1871          *
   1872          * Return(s)   : none.
   1873          *
   1874          * Caller(s)   : Application.
   1875          *
   1876          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1877          *********************************************************************************************************
   1878          */
   1879          /*$PAGE*/
   1880          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1881          void  Mem_PoolBlkFree (MEM_POOL  *pmem_pool,
   1882                                 void      *pmem_blk,
   1883                                 LIB_ERR   *perr)
   1884          {
   1885              void         *p_addr;
   1886              CPU_BOOLEAN   addr_valid;
   1887              MEM_POOL_IX   i;
   1888              CPU_SR_ALLOC();
   1889          
   1890          
   1891          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1892              if (perr == (LIB_ERR *)0) {
   1893                  CPU_SW_EXCEPTION(;);
   1894              }
   1895          #endif
   1896          
   1897                                                                              /* ------------ VALIDATE MEM POOL FREE ------------ */
   1898          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
   1899              if (pmem_pool == (MEM_POOL *)0) {
   1900                 *perr = LIB_MEM_ERR_NULL_PTR;
   1901                  return;
   1902              }
   1903          
   1904              if (pmem_blk == (void *)0) {
   1905                 *perr = LIB_MEM_ERR_NULL_PTR;
   1906                  return;
   1907              }
   1908          #endif
   1909          
   1910              CPU_CRITICAL_ENTER();
   1911          
   1912          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1913              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   1914                  CPU_CRITICAL_EXIT();
   1915                 *perr = LIB_MEM_ERR_INVALID_POOL;
   1916                  return;
   1917              }
   1918          
   1919              addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
   1920              if (addr_valid != DEF_OK) {
   1921                  CPU_CRITICAL_EXIT();
   1922                 *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   1923                  return;
   1924              }
   1925          
   1926              for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
   1927                  if (pmem_blk == pmem_pool->PoolPtrs[i]) {
   1928                      CPU_CRITICAL_EXIT();
   1929                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   1930                      return;
   1931                  }
   1932              }
   1933          #endif
   1934          
   1935              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT already full.              */
   1936                  CPU_CRITICAL_EXIT();
   1937                 *perr = LIB_MEM_ERR_POOL_FULL;
   1938                  return;
   1939              }
   1940          
   1941                                                                              /* ------------- FREE MEM BLK TO POOL ------------- */
   1942              addr_valid = DEF_NO;
   1943              for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk to free.                      */
   1944                  p_addr = pmem_pool->PoolPtrs[i];
   1945                  if (p_addr == pmem_blk) {
   1946                      addr_valid = DEF_YES;
   1947                      break;
   1948                  }
   1949              }
   1950                                                                              /* Swap addr of mem blk to free in tbl.             */
   1951              if (addr_valid == DEF_YES) {
   1952                  pmem_pool->PoolPtrs[i] = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
   1953              } else {
   1954          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1955                  CPU_CRITICAL_EXIT();
   1956                 *perr = LIB_MEM_ERR_INVALID_POOL;
   1957                  return;
   1958          #endif
   1959              }
   1960          
   1961                                                                              /* Free mem blk.                                    */
   1962              pmem_pool->PoolPtrs[pmem_pool->BlkIx] = pmem_blk;
   1963              pmem_pool->BlkIx++;
   1964          
   1965              CPU_CRITICAL_EXIT();
   1966          
   1967             *perr = LIB_MEM_ERR_NONE;
   1968          }
   1969          #endif
   1970          
   1971          
   1972          /*$PAGE*/
   1973          /*
   1974          *********************************************************************************************************
   1975          *                                          Mem_PoolBlkIxGet()
   1976          *
   1977          * Description : Get temporary index of a memory block in a memory pool.
   1978          *
   1979          * Argument(s) : pmem_pool   Pointer to memory pool.
   1980          *
   1981          *               pmem_blk    Pointer to memory block to get index for.
   1982          *
   1983          *               perr        Pointer to variable that will receive the return error code from this function :
   1984          *
   1985          *                               LIB_MEM_ERR_NONE                        Memory block successfully freed.
   1986          *                               LIB_MEM_ERR_POOL_FULL                   ALL memory blocks already available in
   1987          *                                                                           memory pool.
   1988          *
   1989          *                               LIB_MEM_ERR_NULL_PTR                    Argument 'pmem_pool'/'pmem_blk' passed
   1990          *                                                                           a NULL pointer.
   1991          *                               LIB_MEM_ERR_INVALID_POOL                Invalid memory pool  type.
   1992          *                               LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1993          *                               LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1994          *                                                                            in memory pool.
   1995          *
   1996          * Return(s)   : Index of the memory block.
   1997          *
   1998          * Caller(s)   : Application.
   1999          *
   2000          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   2001          *
   2002          *               (2) The returned index can be altered when Mem_PoolBlkFree() is called. This index must
   2003          *                   only be used in conjunction with Mem_PoolBlkGetUsedAtIx() if holding a proper
   2004          *                   lock to avoid the index to be modified.
   2005          *********************************************************************************************************
   2006          */
   2007          /*$PAGE*/
   2008          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   2009          MEM_POOL_IX  Mem_PoolBlkIxGet (MEM_POOL  *pmem_pool,
   2010                                         void      *pmem_blk,
   2011                                         LIB_ERR   *perr)
   2012          {
   2013              void         *p_addr;
   2014              CPU_BOOLEAN   addr_valid;
   2015              MEM_POOL_IX   i;
   2016              MEM_POOL_IX   pool_ix;
   2017              MEM_POOL_IX   invalid_ix;
   2018              CPU_SR_ALLOC();
   2019          
   2020          
   2021              invalid_ix = DEF_GET_U_MAX_VAL(MEM_POOL_IX);
   2022          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   2023              if (perr == (LIB_ERR *)0) {
   2024                  CPU_SW_EXCEPTION(invalid_ix);
   2025              }
   2026          #endif
   2027          
   2028                                                                              /* ------------ VALIDATE MEM POOL FREE ------------ */
   2029          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
   2030              if (pmem_pool == (MEM_POOL *)0) {
   2031                 *perr = LIB_MEM_ERR_NULL_PTR;
   2032                  return (invalid_ix);
   2033              }
   2034          
   2035              if (pmem_blk == (void *)0) {
   2036                 *perr = LIB_MEM_ERR_NULL_PTR;
   2037                  return (invalid_ix);
   2038              }
   2039          #endif
   2040          
   2041              CPU_CRITICAL_ENTER();
   2042          
   2043          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2044              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   2045                  CPU_CRITICAL_EXIT();
   2046                 *perr = LIB_MEM_ERR_INVALID_POOL;
   2047                  return(invalid_ix);
   2048              }
   2049          
   2050              addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
   2051              if (addr_valid != DEF_OK) {
   2052                  CPU_CRITICAL_EXIT();
   2053                 *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   2054                  return (invalid_ix);
   2055              }
   2056          
   2057              for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
   2058                  if (pmem_blk == pmem_pool->PoolPtrs[i]) {
   2059                      CPU_CRITICAL_EXIT();
   2060                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   2061                      return (invalid_ix);
   2062                  }
   2063              }
   2064          #endif
   2065          
   2066              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT full.                      */
   2067                  CPU_CRITICAL_EXIT();
   2068                 *perr = LIB_MEM_ERR_POOL_FULL;
   2069                  return (invalid_ix);
   2070              }
   2071          
   2072              addr_valid = DEF_NO;
   2073              for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk.                              */
   2074                  p_addr = pmem_pool->PoolPtrs[i];
   2075                  if (p_addr == pmem_blk) {
   2076                      addr_valid = DEF_YES;
   2077                      break;
   2078                  }
   2079              }
   2080                                                                              /* Return ix of mem blk in tbl.                     */
   2081              if (addr_valid == DEF_YES) {
   2082                  pool_ix = pmem_pool->BlkNbr - 1 - i;
   2083                  CPU_CRITICAL_EXIT();
   2084                 *perr = LIB_MEM_ERR_NONE;
   2085                  return (pool_ix);
   2086              } else {
   2087                  CPU_CRITICAL_EXIT();
   2088                 *perr = LIB_MEM_ERR_INVALID_POOL;
   2089                  return (invalid_ix);
   2090              }
   2091          
   2092          }
   2093          #endif
   2094          
   2095          
   2096          /*$PAGE*/
   2097          /*
   2098          *********************************************************************************************************
   2099          *********************************************************************************************************
   2100          *                                           LOCAL FUNCTIONS
   2101          *********************************************************************************************************
   2102          *********************************************************************************************************
   2103          */
   2104          
   2105          /*
   2106          *********************************************************************************************************
   2107          *                                      Mem_PoolBlkIsValidAddr()
   2108          *
   2109          * Description : Calculates if a given memory block address is valid for the memory pool.
   2110          *
   2111          * Argument(s) : pmem_pool   Pointer to memory pool structure to validate memory block address.
   2112          *               ---------   Argument validated in Mem_PoolBlkFree().
   2113          *
   2114          *               pmem_blk    Pointer to memory block address to validate.
   2115          *               --------    Argument validated in Mem_PoolBlkFree().
   2116          *
   2117          * Return(s)   : DEF_YES, if valid memory pool block address.
   2118          *
   2119          *               DEF_NO,  otherwise.
   2120          *
   2121          * Caller(s)   : Mem_PoolBlkFree().
   2122          *
   2123          * Note(s)     : none.
   2124          *********************************************************************************************************
   2125          */
   2126          
   2127          #if ((LIB_MEM_CFG_ALLOC_EN       == DEF_ENABLED) && \
   2128               (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED))
   2129          static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *pmem_pool,
   2130                                                       void      *pmem_blk)
   2131          {
   2132              CPU_INT08U   *ppool_addr_first;
   2133              void         *ppool_addr_start;
   2134              void         *ppool_addr_end;
   2135              CPU_SIZE_T    align_offset;
   2136              CPU_SIZE_T    blk_align;
   2137              CPU_SIZE_T    blk_align_offset;
   2138              CPU_SIZE_T    blk_size;
   2139              CPU_SIZE_T    mem_align;
   2140              CPU_SIZE_T    mem_align_offset;
   2141              CPU_SIZE_T    mem_diff;
   2142              CPU_BOOLEAN   addr_valid;
   2143          
   2144          
   2145              ppool_addr_start = pmem_pool->PoolAddrStart;
   2146              ppool_addr_end   = pmem_pool->PoolAddrEnd;
   2147          
   2148              if ((pmem_blk < ppool_addr_start) ||
   2149                  (pmem_blk > ppool_addr_end)) {
   2150                  return (DEF_NO);
   2151              }
   2152          
   2153              blk_align      = (CPU_SIZE_T)pmem_pool->BlkAlign;
   2154              align_offset   = (CPU_SIZE_T)((CPU_ADDR)ppool_addr_start % blk_align);
   2155              if (align_offset != 0u) {
   2156                  mem_align_offset = blk_align - align_offset;
   2157              } else {
   2158                  mem_align_offset = 0u;
   2159              }
   2160          
   2161              blk_size     = pmem_pool->BlkSize;
   2162              align_offset = blk_size % blk_align;
   2163              if (align_offset != 0u) {
   2164                  blk_align_offset = blk_align - align_offset;
   2165              } else {
   2166                  blk_align_offset = 0u;
   2167              }
   2168          
   2169              ppool_addr_first = (CPU_INT08U *)((CPU_INT08U *)ppool_addr_start + mem_align_offset);
   2170              mem_diff         = (CPU_SIZE_T  )((CPU_INT08U *)pmem_blk         - ppool_addr_first);
   2171              mem_align        = (CPU_SIZE_T  )(              blk_size         + blk_align_offset);
   2172          
   2173              addr_valid       = ((mem_diff % mem_align) == 0u) ? DEF_YES : DEF_NO;
   2174          
   2175              return (addr_valid);
   2176          }
   2177          #endif
   2178          
   2179          
   2180          /*$PAGE*/
   2181          /*
   2182          *********************************************************************************************************
   2183          *                                        Mem_SegCalcTotSize()
   2184          *
   2185          * Description : (1) Calculates total memory segment size for number of blocks with specific size & alignment :
   2186          *
   2187          *
   2188          *                       -----                     ======================  ---
   2189          *                         ^       Mem Addr  --->  |  /  /  /  /  /  /  |   ^
   2190          *                         |    (see Note #1a)     | /  /  /  /  /  /  /|   |    Mem Align Offset
   2191          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1e & #2a)
   2192          *                         |                       |  /  /  /  /  /  /  |   v
   2193          *                         |                       ======================  ---
   2194          *                         |                       |                    |   ^
   2195          *                         |                       |                    |   |
   2196          *                         |                       |     Mem Blk #1     |   |        Blk Size
   2197          *                         |                       |                    |   |     (see Note #1c)
   2198          *                         |                       |                    |   v
   2199          *                         |                       ----------------------  ---
   2200          *                         |                       |  /  /  /  /  /  /  |   ^
   2201          *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
   2202          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
   2203          *                         |                       |  /  /  /  /  /  /  |   v
   2204          *                         |                       ======================  ---
   2205          *                                                 |         .          |
   2206          *                     Total Size                  |         .          |
   2207          *                   (see Note #2c)                |         .          |
   2208          *                                                 ======================  ---
   2209          *                         |                       |                    |   ^
   2210          *                         |                       |                    |   |
   2211          *                         |                       |   Mem Blk #N - 1   |   |        Blk Size
   2212          *                         |                       |                    |   |     (see Note #1c)
   2213          *                         |                       |                    |   v
   2214          *                         |                       ----------------------  ---
   2215          *                         |                       |  /  /  /  /  /  /  |   ^
   2216          *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
   2217          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
   2218          *                         |                       |  /  /  /  /  /  /  |   v
   2219          *                         |                       ======================  ---
   2220          *                         |                       |                    |   ^
   2221          *                         |                       |                    |   |
   2222          *                         |                       |     Mem Blk #N     |   |        Blk Size
   2223          *                         |                       |                    |   |     (see Note #1c)
   2224          *                         v                       |                    |   v
   2225          *                       -----                     ======================  ---
   2226          *
   2227          *               where
   2228          *
   2229          *                   (a) Mem Addr            Memory address of the beginning of the memory block ('pmem_addr')
   2230          *
   2231          *                   (b) N                   Number of memory blocks to allocate ('blk_nbr')
   2232          *
   2233          *                   (c) Blk Size            Size   of memory block  to allocate ('blk_size')
   2234          *
   2235          *                   (d) Align               Required block memory alignment     ('blk_align')
   2236          *
   2237          *                   (e) Mem Align Offset    Offset required to align first memory block
   2238          *
   2239          *                   (f) Blk Align Offset    Offset required to align every memory block
   2240          *
   2241          *
   2242          *               (2) The total size is calculated based on the following equations :
   2243          *
   2244          *                                            { (1) Align - (Mem Addr % Align) , if memory address is not aligned
   2245          *                   (a) Mem Align Offset  =  {
   2246          *                                            { (2) 0                          , if memory address is     aligned
   2247          *
   2248          *
   2249          *                                            { (1) Align - (Size     % Align) , if memory block   is not aligned
   2250          *                   (b) Blk Align Offset  =  {
   2251          *                                            { (2) 0                          , if memory block   is     aligned
   2252          *
   2253          *
   2254          *                   (c) Total Size        =   Mem Align Offset
   2255          *                                         + ((Blk Size + Blk Align Offset) * (N - 1))
   2256          *                                         +   Blk Size
   2257          *
   2258          *
   2259          * Argument(s) : pmem_addr   Memory address of the beginning of the memory block.
   2260          *
   2261          *               blk_nbr     Number of memory blocks to allocate.
   2262          *               -------     Argument checked in Mem_HeapAlloc(),
   2263          *                                               Mem_PoolCreate().
   2264          *
   2265          *               blk_size    Size   of memory block  to allocate.
   2266          *               --------    Argument checked in Mem_HeapAlloc(),
   2267          *                                               Mem_PoolCreate().
   2268          *
   2269          *               blk_align   Required block word-boundary memory alignment (in octets).
   2270          *               ---------   Argument checked in Mem_HeapAlloc(),
   2271          *                                               Mem_PoolCreate().
   2272          *
   2273          * Return(s)   : Total size of memory segment used to allocate the number of blocks, if NO error(s).
   2274          *
   2275          *               0,                                                                  otherwise.
   2276          *$PAGE*
   2277          * Caller(s)   : Mem_HeapAlloc(),
   2278          *               Mem_PoolCreate().
   2279          *
   2280          * Note(s)     : none.
   2281          *********************************************************************************************************
   2282          */
   2283          
   2284          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   2285          static  CPU_SIZE_T  Mem_SegCalcTotSize (void              *pmem_addr,
   2286                                                  MEM_POOL_BLK_QTY   blk_nbr,
   2287                                                  CPU_SIZE_T         blk_size,
   2288                                                  CPU_SIZE_T         blk_align)
   2289          {
   2290          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2291              CPU_SIZE_T  blk_size_mem_aligned;
   2292              CPU_SIZE_T  blk_size_aligned;
   2293              CPU_SIZE_T  blk_size_aligned_nbr;
   2294              CPU_SIZE_T  blk_size_tot;
   2295          #endif
   2296              CPU_SIZE_T  align_offset;
   2297              CPU_SIZE_T  mem_align_offset;
   2298              CPU_SIZE_T  blk_align_offset;
   2299              CPU_SIZE_T  size_tot;
   2300          
   2301                                                                              /* Calc mem align (see Note #2a).                   */
   2302              align_offset = (CPU_ADDR)pmem_addr % blk_align;
   2303              if (align_offset != 0u) {
   2304                  mem_align_offset = blk_align - align_offset;
   2305              } else {
   2306                  mem_align_offset = 0u;
   2307              }
   2308                                                                              /* Calc blk align (see Note #2b).                   */
   2309              align_offset = blk_size % blk_align;
   2310              if (align_offset != 0u) {
   2311                  blk_align_offset = blk_align - align_offset;
   2312              } else {
   2313                  blk_align_offset = 0u;
   2314              }
   2315                                                                              /* Calc tot size  (see Note #2c).                   */
   2316              size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
   2317          
   2318          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
   2319              blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
   2320              if ((blk_size_mem_aligned < mem_align_offset) ||
   2321                  (blk_size_mem_aligned < blk_size)) {
   2322                  return (0u);
   2323              }
   2324          
   2325              if (blk_nbr > 1) {
   2326                  blk_size_aligned = blk_size + blk_align_offset;
   2327                  if ((blk_size_aligned < blk_align_offset) ||                /* Chk ovf of      (B + C) :                        */
   2328                      (blk_size_aligned < blk_size)) {
   2329                      return (0u);
   2330                  }
   2331          
   2332                  blk_size_aligned_nbr = blk_size_aligned * ((CPU_SIZE_T)blk_nbr - 1);
   2333                  if ((blk_size_aligned_nbr < blk_size_aligned) ||            /* Chk ovf of     [(B + C) * D] :                   */
   2334                      (blk_size_aligned_nbr < blk_align_offset) ||
   2335                      (blk_size_aligned_nbr < blk_size)) {
   2336                      return (0u);
   2337                  }
   2338          
   2339                  blk_size_tot = blk_size_aligned_nbr + blk_size;
   2340                  if ((blk_size_tot < blk_size_aligned_nbr) ||                /* Chk ovf of     [(B + C) * D] + E :               */
   2341                      (blk_size_tot < blk_size)) {
   2342                      return (0u);
   2343                  }
   2344          
   2345                  if ((size_tot < blk_size_mem_aligned) ||                    /* Chk ovf of A + [(B + C) * D] + E :               */
   2346                      (size_tot < blk_size_aligned_nbr) ||
   2347                      (size_tot < blk_size_tot)) {
   2348                      return (0u);
   2349                  }
   2350              }
   2351          #endif
   2352          
   2353              return (size_tot);
   2354          }
   2355          #endif
   2356          
   2357          
   2358          /*$PAGE*/
   2359          /*
   2360          *********************************************************************************************************
   2361          *                                           Mem_SegAlloc()
   2362          *
   2363          * Description : Allocates memory from specific segment.
   2364          *
   2365          * Argument(s) : pmem_pool   Pointer to memory pool structure containing segment information.
   2366          *               ---------   Argument validated in Mem_HeapAlloc(),
   2367          *                                                 Mem_PoolCreate().
   2368          *
   2369          *               size        Size of memory to allocate.
   2370          *               ----        Argument validated in Mem_HeapAlloc(),
   2371          *                                                 Mem_PoolCreate().
   2372          *
   2373          *               align       Required starting word-boundary memory alignment (in octets).
   2374          *               -----       Argument validated in Mem_HeapAlloc(),
   2375          *                                                 Mem_PoolCreate().
   2376          *
   2377          * Return(s)   : Pointer to allocated memory, if NO error(s).
   2378          *
   2379          *               Pointer to NULL,             otherwise.
   2380          *
   2381          * Caller(s)   : Mem_HeapAlloc(),
   2382          *               Mem_PoolCreate().
   2383          *
   2384          * Note(s)     : (1) Allocated memory from the specific segment is NEVER freed after allocation.
   2385          *
   2386          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   2387          *
   2388          *                   (a) However, this function is already called within critical sections.
   2389          *********************************************************************************************************
   2390          */
   2391          
   2392          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   2393          static  void  *Mem_SegAlloc (MEM_POOL    *pmem_pool,
   2394                                       CPU_SIZE_T   size,
   2395                                       CPU_SIZE_T   align)
   2396          {
   2397              CPU_INT08U  *pmem_addr;
   2398              CPU_INT08U  *pmem_addr_next;
   2399              CPU_SIZE_T   mem_align;
   2400              CPU_SIZE_T   align_offset;
   2401              CPU_SIZE_T   size_tot;
   2402          
   2403          
   2404              pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;
   2405          
   2406              mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */
   2407          
   2408              if (mem_align != 0u) {
   2409                  align_offset = align - mem_align;
   2410              } else {
   2411                  align_offset = 0u;
   2412              }
   2413          
   2414              size_tot = align_offset + size;
   2415              if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
   2416                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   2417              }
   2418          
   2419          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2420              if ((size_tot < align_offset) ||                                /* If size ovf, ...                                 */
   2421                  (size_tot < size)) {
   2422                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   2423              }
   2424          #endif
   2425          
   2426              pmem_addr_next = pmem_addr + size_tot;
   2427          
   2428          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2429              if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
   2430                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   2431              }
   2432          #endif
   2433          
   2434              pmem_addr += align_offset;                                      /* Align mem addr.                                  */
   2435          
   2436              pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
   2437              pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
   2438          
   2439              return ((void *)pmem_addr);
   2440          }
   2441          #endif
   2442          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Mem_Clr
         8   -> __aeabi_memclr
      12   Mem_Cmp
       0   Mem_Init
       8   Mem_Move
         8   -> Mem_Copy
       8   Mem_Set
         8   -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      62  Mem_Clr
     122  Mem_Cmp
       2  Mem_Init
     122  Mem_Move
      76  Mem_Set

 
 384 bytes in section .text
 
 384 bytes of CODE memory

Errors: none
Warnings: none
